##### Fichier Source formule ACT-2001 ####

## Pour accéder rapidement au formule dans votre session de travail
## actuelle :
## 1. Copier-coller ce fichier .R dans le même dossier où se
## trouve votre script et entrez source('TVaRFormulas.R')
## source('~/Box Sync/Ulaval/Parascolaire/Programmation/R/script_r/TVaRFormulas/TVaRFormulas.R')
##(Il faudra modifier le chemin d'accès pour votre poste informatique)

## Autre option : Ctrl + A et appuyez sur 'Source'. Copiez-coller le
## texte qui apparait dans la console et mettez le dans votre script
## de travail

## ---
## CONVENTION POUR LES FORMULES (sensible à la majuscule)
# E_<loi>        : Espérance
# V_<loi>        : Variance
# Etronq_<loi>   : Espérance tronquée
# Elim_<loi>     : Espérance limitée
# SL_<loi>       : Fonction Stop-Loss
# VaR_<loi>      : Value-At-risk
# TVaR_<loi>     : Tail Value-at-risk
# MExcess_<loi>  : Mean Excess loss

## Auteur du fichier : Gabriel-Crépeault-Cauchon
## Hiver 2018
library(actuar) # nécessaire pour que les formules fonctionnent
## au besoin, on fait la fonction rm(list = ls()) pour reset
## ---

### Loi discrètes ####
## Binomiale ok

# la loi de Bernouilli est une binomiale avec n = 1

## Binomiale négative
# La loi géométrique est une binomiale négative avec r = 1

## Loi continues ####
## Uniforme ok
## Exponentielle ok
## Gamma ok

## Beta (à venir)
{

}

## Erlang (à venir)
{

}

## Erlang généralisée (à venir)
{

}

## Lornormale (coquille, à revalider)
{
    E_lnorm <- function(mu, sig) exp(mu + (sig^2 / 2))
    V_lnorm <- function(mu, sig) exp(2*mu + sig^2) * (exp(sig^2) - 1)
    Etronq_lnorm <- function(d, mu, sig)
    {
        phi <- (log(d) - mu - sig^2) / sig
        E_lnorm(mu, sig) * pnorm(phi)
    }
    VaR_lnorm <- function(kappa, mu, sig)
    {
        exp(mu + sig * qnorm(kappa))
    }
    TVaR_lnorm <- function(kappa, mu, sig)
    {
        phi <- qnorm(kappa) - sig
        (E_lnorm(mu, sig) * (1 - pnorm(phi))) / (1-kappa)
    }
    SL_lnorm <- function(d, mu, sig)
    {
        phi1 <- (log(d) - mu - sig^2) / sig
        phi2 <- (log(d) - mu) / sig
        E_lnorm(mu, sig) * (1 - pnorm(phi1)) - d * (1 - pnorm(phi2))
    }
    Mexcess_lnorm <- function(d, mu, sig)
    {
        phi1 <- (log(d) - mu - sig^2) / sig
        phi2 <- (log(d) - mu) / sig
        x <- (E_lnorm(mu, sig) * (1 - pnorm(phi1)))
        (x / (1 - pnorm(phi2))) - d
    }
    Elim_lnorm <- function(d, mu, sig)
    {
        phi1 <- (log(d) - mu - sig^2) / sig
        phi2 <- (log(d) - mu) / sig
        E_lnorm(mu, sig) * pnorm(phi1) + d * (1 - pnorm(phi2))
    }
}

## Inverse Gaussienne (à venir)
{

}

## Pareto
{
    E_pareto <- function(alph, lam) lam / (alph - 1)
    V_pareto <- function(alph, lam)
    {
        (alph*lam^2) / ((alph - 1)^2 * (alph -2))
    }
    Etronq_pareto <- function(d, alph, lam)
    {
        un <- E_pareto(alph, lam) * ppareto(d, alph - 1, lam)
        deux <- d * (1 - ppareto(d, alph, lam))
        un - deux
    }
    VaR_pareto <- function(kappa, alph, lam)
    {
        lam * ((1-kappa)^(-1/alph) - 1)
    }
    TVaR_pareto <- function(kappa, alph, lam)
    {
        fact_tvar <- alph / (alph - 1)
        lam * (fact_tvar * (1-kappa)^(-1/alph) - 1)
    }
    SL_pareto <- function(d, alph, lam)
    {
        E_pareto(alph, lam) * (1 - ppareto(d, alph - 1, lam))
    }
    Mexcess_pareto <- function(d, alph, lam) E_pareto(alph, lam + d)
    Elim_pareto <- function(d, alph, lam)
    {
        E_pareto(alph, lam) * ppareto(d, alph - 1, lam)
    }
}

## F-Généralisée (à venir)
{

}

## Burr
{
    E_burr <- function(lam, alph, rho)
    {
        un <- lam^(1/rho) * gamma(1 + 1/rho) * gamma(alph - 1/rho)
        un / gamma(alph)
    }
    V_burr <- function(lam, alph, rho)
    {
        un <- gamma(1 + 2/rho) * gamma(alph - 2/rho)
        deux <- (gamma(1 + 1/rho)*gamma(alph - 1/rho))^2 / gamma(alph)
        trois <- lam^(2/rho) / gamma(alph)
        trois * (un - deux)
    }

}

## Log-logistique (à venir)
{

}

## Loi normale
{
    # pas de formule pour mu et sigma^2 ...
    Etronq_norm <- function(d, mu = 0, sig = 1)
    {
        phi1 <- (d - mu) / sig
        mu * pnorm(phi1) - (sig/sqrt(2*pi)) * exp(-phi1^2 / 2)
    }
    VaR_norm <- function(kappa, mu = 0, sig = 1)
    {
        mu + sig * qnorm(kappa)
    }
    TVaR_norm <-function(kappa, mu = 0, sig = 1)
    {
        tvar_fact <- sig/((1-kappa) * sqrt(2*pi))
        z <- exp(-(qnorm(kappa))^2 / 2)
        mu + tvar_fact * z
    }
    SL_norm <- function(d,mu = 0, sig = 1)
    {
        phi1 <- (d - mu) / sig
        fact_norm <- (sig / sqrt(2*pi)) * exp(-phi1^2 / 2)
        (mu + d)*(1 - pnorm(phi1)) - fact_norm
    }
    Mexcess_norm <- function(d, mu = 0, sig = 1)
    {
        phi1 <- (d - mu) / sig
        fact_norm <- (sig / sqrt(2*pi)) * exp(-phi1^2 / 2)
        mu + d - fact_norm / (1 - pnorm(phi1))
    }
    Elim_norm <- function(d, mu = 0, sig = 1)
    {
        phi1 <- (d - mu) / sig
        fact_norm <- (sig / sqrt(2*pi)) * exp(-phi1^2 / 2)
        mu * pnorm(phi1) - fact_norm + d*(1 - pnorm(phi1))
    }
}

## Loi Student (à venir, coquilles dans Annexe)
{

}

##








