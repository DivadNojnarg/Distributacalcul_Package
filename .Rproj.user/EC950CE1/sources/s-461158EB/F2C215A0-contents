##### Fichier Source formule ACT-2001 ####

## Pour accéder rapidement au formule dans votre session de travail
## actuelle :
## 1. Copier-coller ce fichier .R dans le même dossier où se
## trouve votre script et entrez source('TVaRFormulas.R')
## source('~/Box Sync/Ulaval/Parascolaire/Programmation/R/script_r/TVaRFormulas/TVaRFormulas.R')
##(Il faudra modifier le chemin d'accès pour votre poste informatique)

## Autre option : Ctrl + A et appuyez sur 'Source'. Copiez-coller le
## texte qui apparait dans la console et mettez le dans votre script
## de travail

## ---
## CONVENTION POUR LES FORMULES (sensible à la majuscule)
# E_<loi>        : Espérance
# V_<loi>        : Variance
# Etronq_<loi>   : Espérance tronquée
# Elim_<loi>     : Espérance limitée
# SL_<loi>       : Fonction Stop-Loss
# VaR_<loi>      : Value-At-risk
# TVaR_<loi>     : Tail Value-at-risk
# MExcess_<loi>  : Mean Excess loss

## Auteur du fichier : Gabriel-Crépeault-Cauchon
## Hiver 2018
library(actuar) # nécessaire pour que les formules fonctionnent
## au besoin, on fait la fonction rm(list = ls()) pour reset
## ---

### Loi discrètes ####
## Binomiale
E_binom <- function(n, q) n * q
V_binom <- function(n, q) n * q * (1 - q)

# la loi de Bernouilli est une binomiale avec n = 1

## Binomiale négative
E_nbinom <- function(r, q) r * ((1-q) / q  )
V_nbinom <- function(r, q) r * ((1-q) / q^2)
# La loi géométrique est une binomiale négative avec r = 1

## Loi continues ####
## Uniforme
{
    E_unif <- function(a, b) (a+b) / 2
    V_unif <- function(a, b) (b-a)^2 / 12
    Etronq_unif <- function(d,a, b) (d^2 -a^2) / (2*(b-a))
    VaR_unif <- function(kappa, a, b) a + (b-a) * kappa
    TVaR_unif <- function(kappa, a, b) a + (1/2)*(b-a)*(1+kappa)
    SL_unif <- function(d, a, b) (b-d)^2 / (2*(b-a))
    Mexcess_unif <- function(d, a, b) (b-d) / 2
    Elim_unif <- function(d, a, b) (d^2 - a^2) / (2*(b-a)) + d*((b-d) / (b-a))

}

## Exponentielle
{
    E_exp <- function(b) 1/b
    V_exp <- function(b) 1/b^2
    Etronq_exp <- function(d, b) (1/b)*(1 - exp(-b*d)) - d*exp(-b*d)
    VaR_exp <- function(kappa, b) -log(1 - kappa) / b
    TVaR_exp <- function(kappa, b) VaR_exp(b, kappa) + E_exp(b)
    SL_exp <- function(d, b) exp(-b*d) / b
    Mexcess_exp <- function(d, b) 1/b
    Elim_exp <- function(d, b) (1 - exp(-b*d)) / b
}

## Gamma
{
    E_gamma <- function(a, b) a/b
    V_gamma <- function(a, b) a/b^2
    Etronq_gamma <- function(d, a, b) (a * pgamma(d, a+1, b)) / b
    VaR_gamma <- function(kappa, a, b)
    {
        # On procède par optimisation
        f <- function(x) pgamma(x, a, b) - kappa
        uniroot(f, c(0,99999999999))$root
        # Note : la fonction qgamma nous donne la réponse aussi,
        # mais aucun gain au niveau de la vitesse... je garde l'algo
        # avec Uniroot
    }
    TVaR_gamma <- function(kappa, a, b)
    {
        survie <- 1 - pgamma(VaR_gamma(a, b, kappa),a + 1, b)
        (a * survie) / (b * (1-kappa))
    }
    SL_gamma <- function(d, a, b)
    {
        premier_morceau <- 1 - pgamma(d, a+1, b)
        deuxieme_morceau <- 1 - pgamma(d, a, b)
        (a/b)*premier_morceau - d*deuxieme_morceau
    }
    Mexcess_gamma <- function(d, a, b)
    {
        numerateur   <- a * (1 - pgamma(d, a+1, b))
        denominateur <- b * (1 - pgamma(d, a  , b))
        (numerateur/denominateur) - d
    }
    Elim_gamma <- function(d, a, b)
    {
        un   <- (a/b) *  pgamma(d, a+1, b)
        deux <- d * (1 - pgamma(d,  a, b))
        un  + deux
    }
}

## Beta (à venir)
{

}

## Erlang (à venir)
{

}

## Erlang généralisée (à venir)
{

}

## Lornormale (coquille, à revalider)
{
    E_lnorm <- function(mu, sig) exp(mu + (sig^2 / 2))
    V_lnorm <- function(mu, sig) exp(2*mu + sig^2) * (exp(sig^2) - 1)
    Etronq_lnorm <- function(d, mu, sig)
    {
        phi <- (log(d) - mu - sig^2) / sig
        E_lnorm(mu, sig) * pnorm(phi)
    }
    VaR_lnorm <- function(kappa, mu, sig)
    {
        exp(mu + sig * qnorm(kappa))
    }
    TVaR_lnorm <- function(kappa, mu, sig)
    {
        phi <- qnorm(kappa) - sig
        (E_lnorm(mu, sig) * (1 - pnorm(phi))) / (1-kappa)
    }
    SL_lnorm <- function(d, mu, sig)
    {
        phi1 <- (log(d) - mu - sig^2) / sig
        phi2 <- (log(d) - mu) / sig
        E_lnorm(mu, sig) * (1 - pnorm(phi1)) - d * (1 - pnorm(phi2))
    }
    Mexcess_lnorm <- function(d, mu, sig)
    {
        phi1 <- (log(d) - mu - sig^2) / sig
        phi2 <- (log(d) - mu) / sig
        x <- (E_lnorm(mu, sig) * (1 - pnorm(phi1)))
        (x / (1 - pnorm(phi2))) - d
    }
    Elim_lnorm <- function(d, mu, sig)
    {
        phi1 <- (log(d) - mu - sig^2) / sig
        phi2 <- (log(d) - mu) / sig
        E_lnorm(mu, sig) * pnorm(phi1) + d * (1 - pnorm(phi2))
    }
}

## Inverse Gaussienne (à venir)
{

}

## Pareto
{
    E_pareto <- function(alph, lam) lam / (alph - 1)
    V_pareto <- function(alph, lam)
    {
        (alph*lam^2) / ((alph - 1)^2 * (alph -2))
    }
    Etronq_pareto <- function(d, alph, lam)
    {
        un <- E_pareto(alph, lam) * ppareto(d, alph - 1, lam)
        deux <- d * (1 - ppareto(d, alph, lam))
        un - deux
    }
    VaR_pareto <- function(kappa, alph, lam)
    {
        lam * ((1-kappa)^(-1/alph) - 1)
    }
    TVaR_pareto <- function(kappa, alph, lam)
    {
        fact_tvar <- alph / (alph - 1)
        lam * (fact_tvar * (1-kappa)^(-1/alph) - 1)
    }
    SL_pareto <- function(d, alph, lam)
    {
        E_pareto(alph, lam) * (1 - ppareto(d, alph - 1, lam))
    }
    Mexcess_pareto <- function(d, alph, lam) E_pareto(alph, lam + d)
    Elim_pareto <- function(d, alph, lam)
    {
        E_pareto(alph, lam) * ppareto(d, alph - 1, lam)
    }
}

## F-Généralisée (à venir)
{

}

## Burr
{
    E_burr <- function(lam, alph, rho)
    {
        un <- lam^(1/rho) * gamma(1 + 1/rho) * gamma(alph - 1/rho)
        un / gamma(alph)
    }
    V_burr <- function(lam, alph, rho)
    {
        un <- gamma(1 + 2/rho) * gamma(alph - 2/rho)
        deux <- (gamma(1 + 1/rho)*gamma(alph - 1/rho))^2 / gamma(alph)
        trois <- lam^(2/rho) / gamma(alph)
        trois * (un - deux)
    }

}

## Log-logistique (à venir)
{

}

## Loi normale
{
    # pas de formule pour mu et sigma^2 ...
    Etronq_norm <- function(d, mu = 0, sig = 1)
    {
        phi1 <- (d - mu) / sig
        mu * pnorm(phi1) - (sig/sqrt(2*pi)) * exp(-phi1^2 / 2)
    }
    VaR_norm <- function(kappa, mu = 0, sig = 1)
    {
        mu + sig * qnorm(kappa)
    }
    TVaR_norm <-function(kappa, mu = 0, sig = 1)
    {
        tvar_fact <- sig/((1-kappa) * sqrt(2*pi))
        z <- exp(-(qnorm(kappa))^2 / 2)
        mu + tvar_fact * z
    }
    SL_norm <- function(d,mu = 0, sig = 1)
    {
        phi1 <- (d - mu) / sig
        fact_norm <- (sig / sqrt(2*pi)) * exp(-phi1^2 / 2)
        (mu + d)*(1 - pnorm(phi1)) - fact_norm
    }
    Mexcess_norm <- function(d, mu = 0, sig = 1)
    {
        phi1 <- (d - mu) / sig
        fact_norm <- (sig / sqrt(2*pi)) * exp(-phi1^2 / 2)
        mu + d - fact_norm / (1 - pnorm(phi1))
    }
    Elim_norm <- function(d, mu = 0, sig = 1)
    {
        phi1 <- (d - mu) / sig
        fact_norm <- (sig / sqrt(2*pi)) * exp(-phi1^2 / 2)
        mu * pnorm(phi1) - fact_norm + d*(1 - pnorm(phi1))
    }
}

## Loi Student (à venir, coquilles dans Annexe)
{

}

##








