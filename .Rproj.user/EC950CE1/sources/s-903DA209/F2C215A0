{
    "collab_server" : "",
    "contents" : "##### Fichier Source formule ACT-2001 ####\n\n## Pour accéder rapidement au formule dans votre session de travail\n## actuelle :\n## 1. Copier-coller ce fichier .R dans le même dossier où se\n## trouve votre script et entrez source('TVaRFormulas.R')\n## source('~/Box Sync/Ulaval/Parascolaire/Programmation/R/script_r/TVaRFormulas/TVaRFormulas.R')\n##(Il faudra modifier le chemin d'accès pour votre poste informatique)\n\n## Autre option : Ctrl + A et appuyez sur 'Source'. Copiez-coller le\n## texte qui apparait dans la console et mettez le dans votre script\n## de travail\n\n## ---\n## CONVENTION POUR LES FORMULES (sensible à la majuscule)\n# E_<loi>        : Espérance\n# V_<loi>        : Variance\n# Etronq_<loi>   : Espérance tronquée\n# Elim_<loi>     : Espérance limitée\n# SL_<loi>       : Fonction Stop-Loss\n# VaR_<loi>      : Value-At-risk\n# TVaR_<loi>     : Tail Value-at-risk\n# MExcess_<loi>  : Mean Excess loss\n\n## Auteur du fichier : Gabriel-Crépeault-Cauchon\n## Hiver 2018\nlibrary(actuar) # nécessaire pour que les formules fonctionnent\n## au besoin, on fait la fonction rm(list = ls()) pour reset\n## ---\n\n### Loi discrètes ####\n## Binomiale\nE_binom <- function(n, q) n * q\nV_binom <- function(n, q) n * q * (1 - q)\n\n# la loi de Bernouilli est une binomiale avec n = 1\n\n## Binomiale négative\nE_nbinom <- function(r, q) r * ((1-q) / q  )\nV_nbinom <- function(r, q) r * ((1-q) / q^2)\n# La loi géométrique est une binomiale négative avec r = 1\n\n## Loi continues ####\n## Uniforme\n{\n    E_unif <- function(a, b) (a+b) / 2\n    V_unif <- function(a, b) (b-a)^2 / 12\n    Etronq_unif <- function(d,a, b) (d^2 -a^2) / (2*(b-a))\n    VaR_unif <- function(kappa, a, b) a + (b-a) * kappa\n    TVaR_unif <- function(kappa, a, b) a + (1/2)*(b-a)*(1+kappa)\n    SL_unif <- function(d, a, b) (b-d)^2 / (2*(b-a))\n    Mexcess_unif <- function(d, a, b) (b-d) / 2\n    Elim_unif <- function(d, a, b) (d^2 - a^2) / (2*(b-a)) + d*((b-d) / (b-a))\n\n}\n\n## Exponentielle\n{\n    E_exp <- function(b) 1/b\n    V_exp <- function(b) 1/b^2\n    Etronq_exp <- function(d, b) (1/b)*(1 - exp(-b*d)) - d*exp(-b*d)\n    VaR_exp <- function(kappa, b) -log(1 - kappa) / b\n    TVaR_exp <- function(kappa, b) VaR_exp(b, kappa) + E_exp(b)\n    SL_exp <- function(d, b) exp(-b*d) / b\n    Mexcess_exp <- function(d, b) 1/b\n    Elim_exp <- function(d, b) (1 - exp(-b*d)) / b\n}\n\n## Gamma\n{\n    E_gamma <- function(a, b) a/b\n    V_gamma <- function(a, b) a/b^2\n    Etronq_gamma <- function(d, a, b) (a * pgamma(d, a+1, b)) / b\n    VaR_gamma <- function(kappa, a, b)\n    {\n        # On procède par optimisation\n        f <- function(x) pgamma(x, a, b) - kappa\n        uniroot(f, c(0,99999999999))$root\n        # Note : la fonction qgamma nous donne la réponse aussi,\n        # mais aucun gain au niveau de la vitesse... je garde l'algo\n        # avec Uniroot\n    }\n    TVaR_gamma <- function(kappa, a, b)\n    {\n        survie <- 1 - pgamma(VaR_gamma(a, b, kappa),a + 1, b)\n        (a * survie) / (b * (1-kappa))\n    }\n    SL_gamma <- function(d, a, b)\n    {\n        premier_morceau <- 1 - pgamma(d, a+1, b)\n        deuxieme_morceau <- 1 - pgamma(d, a, b)\n        (a/b)*premier_morceau - d*deuxieme_morceau\n    }\n    Mexcess_gamma <- function(d, a, b)\n    {\n        numerateur   <- a * (1 - pgamma(d, a+1, b))\n        denominateur <- b * (1 - pgamma(d, a  , b))\n        (numerateur/denominateur) - d\n    }\n    Elim_gamma <- function(d, a, b)\n    {\n        un   <- (a/b) *  pgamma(d, a+1, b)\n        deux <- d * (1 - pgamma(d,  a, b))\n        un  + deux\n    }\n}\n\n## Beta (à venir)\n{\n\n}\n\n## Erlang (à venir)\n{\n\n}\n\n## Erlang généralisée (à venir)\n{\n\n}\n\n## Lornormale (coquille, à revalider)\n{\n    E_lnorm <- function(mu, sig) exp(mu + (sig^2 / 2))\n    V_lnorm <- function(mu, sig) exp(2*mu + sig^2) * (exp(sig^2) - 1)\n    Etronq_lnorm <- function(d, mu, sig)\n    {\n        phi <- (log(d) - mu - sig^2) / sig\n        E_lnorm(mu, sig) * pnorm(phi)\n    }\n    VaR_lnorm <- function(kappa, mu, sig)\n    {\n        exp(mu + sig * qnorm(kappa))\n    }\n    TVaR_lnorm <- function(kappa, mu, sig)\n    {\n        phi <- qnorm(kappa) - sig\n        (E_lnorm(mu, sig) * (1 - pnorm(phi))) / (1-kappa)\n    }\n    SL_lnorm <- function(d, mu, sig)\n    {\n        phi1 <- (log(d) - mu - sig^2) / sig\n        phi2 <- (log(d) - mu) / sig\n        E_lnorm(mu, sig) * (1 - pnorm(phi1)) - d * (1 - pnorm(phi2))\n    }\n    Mexcess_lnorm <- function(d, mu, sig)\n    {\n        phi1 <- (log(d) - mu - sig^2) / sig\n        phi2 <- (log(d) - mu) / sig\n        x <- (E_lnorm(mu, sig) * (1 - pnorm(phi1)))\n        (x / (1 - pnorm(phi2))) - d\n    }\n    Elim_lnorm <- function(d, mu, sig)\n    {\n        phi1 <- (log(d) - mu - sig^2) / sig\n        phi2 <- (log(d) - mu) / sig\n        E_lnorm(mu, sig) * pnorm(phi1) + d * (1 - pnorm(phi2))\n    }\n}\n\n## Inverse Gaussienne (à venir)\n{\n\n}\n\n## Pareto\n{\n    E_pareto <- function(alph, lam) lam / (alph - 1)\n    V_pareto <- function(alph, lam)\n    {\n        (alph*lam^2) / ((alph - 1)^2 * (alph -2))\n    }\n    Etronq_pareto <- function(d, alph, lam)\n    {\n        un <- E_pareto(alph, lam) * ppareto(d, alph - 1, lam)\n        deux <- d * (1 - ppareto(d, alph, lam))\n        un - deux\n    }\n    VaR_pareto <- function(kappa, alph, lam)\n    {\n        lam * ((1-kappa)^(-1/alph) - 1)\n    }\n    TVaR_pareto <- function(kappa, alph, lam)\n    {\n        fact_tvar <- alph / (alph - 1)\n        lam * (fact_tvar * (1-kappa)^(-1/alph) - 1)\n    }\n    SL_pareto <- function(d, alph, lam)\n    {\n        E_pareto(alph, lam) * (1 - ppareto(d, alph - 1, lam))\n    }\n    Mexcess_pareto <- function(d, alph, lam) E_pareto(alph, lam + d)\n    Elim_pareto <- function(d, alph, lam)\n    {\n        E_pareto(alph, lam) * ppareto(d, alph - 1, lam)\n    }\n}\n\n## F-Généralisée (à venir)\n{\n\n}\n\n## Burr\n{\n    E_burr <- function(lam, alph, rho)\n    {\n        un <- lam^(1/rho) * gamma(1 + 1/rho) * gamma(alph - 1/rho)\n        un / gamma(alph)\n    }\n    V_burr <- function(lam, alph, rho)\n    {\n        un <- gamma(1 + 2/rho) * gamma(alph - 2/rho)\n        deux <- (gamma(1 + 1/rho)*gamma(alph - 1/rho))^2 / gamma(alph)\n        trois <- lam^(2/rho) / gamma(alph)\n        trois * (un - deux)\n    }\n\n}\n\n## Log-logistique (à venir)\n{\n\n}\n\n## Loi normale\n{\n    # pas de formule pour mu et sigma^2 ...\n    Etronq_norm <- function(d, mu = 0, sig = 1)\n    {\n        phi1 <- (d - mu) / sig\n        mu * pnorm(phi1) - (sig/sqrt(2*pi)) * exp(-phi1^2 / 2)\n    }\n    VaR_norm <- function(kappa, mu = 0, sig = 1)\n    {\n        mu + sig * qnorm(kappa)\n    }\n    TVaR_norm <-function(kappa, mu = 0, sig = 1)\n    {\n        tvar_fact <- sig/((1-kappa) * sqrt(2*pi))\n        z <- exp(-(qnorm(kappa))^2 / 2)\n        mu + tvar_fact * z\n    }\n    SL_norm <- function(d,mu = 0, sig = 1)\n    {\n        phi1 <- (d - mu) / sig\n        fact_norm <- (sig / sqrt(2*pi)) * exp(-phi1^2 / 2)\n        (mu + d)*(1 - pnorm(phi1)) - fact_norm\n    }\n    Mexcess_norm <- function(d, mu = 0, sig = 1)\n    {\n        phi1 <- (d - mu) / sig\n        fact_norm <- (sig / sqrt(2*pi)) * exp(-phi1^2 / 2)\n        mu + d - fact_norm / (1 - pnorm(phi1))\n    }\n    Elim_norm <- function(d, mu = 0, sig = 1)\n    {\n        phi1 <- (d - mu) / sig\n        fact_norm <- (sig / sqrt(2*pi)) * exp(-phi1^2 / 2)\n        mu * pnorm(phi1) - fact_norm + d*(1 - pnorm(phi1))\n    }\n}\n\n## Loi Student (à venir, coquilles dans Annexe)\n{\n\n}\n\n##\n\n\n\n\n\n\n\n\n",
    "created" : 1519534094292.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "92241503",
    "id" : "F2C215A0",
    "lastKnownWriteTime" : 1519532908,
    "last_content_update" : 1519532908,
    "path" : "~/Box Sync/Ulaval/Parascolaire/Programmation/R/script_r/TVaRFormulas/TVaRFormulas.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}