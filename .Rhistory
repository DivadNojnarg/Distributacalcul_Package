if ((s) > 0) {
##  donc on commence la récursion à partir de f_Sn(1) jusqu'à f_Sn(s)
for (i in (1):(s)) {
# f_S[(i) + 1] <- sum(
#     sapply(1:(i),
#            function(j) {
#                f_X[(j) + 1] * ((n + 1) * ((j) / i) - 1) * f_S[(i - j) + 1]
#            }
#     )
# ) / f_X[(0) + 1]
f_S[(i) + 1] <- sum(f_X[(1:i) + 1] * f_S[(i - 1:i) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
}
}
# sum(f_X[(1:i) + 1] * f_S[(i - 1:i) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
##  retourne f_Sn(s)
return(f_S[(s) + 1])
##  retourne toutes les valeurs de f_Sn de 0 à s
# return(f_S)
}
DePril_RecursiveDensity(s = 10, n = 10, distr = "binom", size = 5, prob = 0.20)
DePril_RecursiveDensity(s = 10, n = 10, distr = "binom", size = 5, prob = 0.20)
DePril_RecursiveDensity <- function(s, n, distr, ...) {
stopifnot(s >= 0, n > 0, distr %in% c("nbinom", "binom", "geom", "pois", "unif"))
##  R commence les positions des vecteurs à 1 alors que nous commencons lles valeurs à f_Sn(0)
##  donc, il faut ajouter 1 à la valeur de S souhaitée lorsque nous voulons extraire une valeur par l'indice de sa position
f_S <- vector(length = (s) + 1)
##  rlang::exec permet d'exécuter une fonction que l'on défini par morceaux
##  ns_env('stats') fait juste dire à R que la fonction d<distr> qu'on cherche est dans le paquetage stats
# e.g. avec distr = "binom" et en mettant size = 5, prob = 0.20 en argument f_X <- dbinom(x = 0:s, size = 5, prob = 0.20)
f_X <- rlang::exec(.fn = paste0("d", distr), x = 0:s, ..., .env = ns_env("stats"))
##  point de départ à 0
f_S[(0) + 1] <- f_X[(0) + 1]^n
##  dans le cas où l'utilisateur spécifie une valeur de s > 0
if ((s) > 0) {
##  donc on commence la récursion à partir de f_Sn(1) jusqu'à f_Sn(s)
for (i in (1):(s)) {
f_S[(i) + 1] <- sum(
sapply(1:(i),
function(j) {
f_X[(j) + 1] * ((n + 1) * ((j) / i) - 1) * f_S[(i - j) + 1]
}
)
) / f_X[(0) + 1]
# f_S[(i) + 1] <- sum(f_X[(1:i) + 1] * f_S[(i - 1:i) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
}
}
# sum(f_X[(1:i) + 1] * f_S[(i - 1:i) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
##  retourne f_Sn(s)
return(f_S[(s) + 1])
##  retourne toutes les valeurs de f_Sn de 0 à s
# return(f_S)
}
DePril_RecursiveDensity(s = 10, n = 10, distr = "binom", size = 5, prob = 0.20)
sum(recur.nrisks(ff = dbinom(x = 0:10, size = 5, prob = 0.20), nn = 10, smax = 10))
DePril_RecursiveDensity <- function(s, n, distr, ...) {
stopifnot(s >= 0, n > 0, distr %in% c("nbinom", "binom", "geom", "pois", "unif"))
##  R commence les positions des vecteurs à 1 alors que nous commencons lles valeurs à f_Sn(0)
##  donc, il faut ajouter 1 à la valeur de S souhaitée lorsque nous voulons extraire une valeur par l'indice de sa position
f_S <- vector(length = (s) + 1)
##  rlang::exec permet d'exécuter une fonction que l'on défini par morceaux
##  ns_env('stats') fait juste dire à R que la fonction d<distr> qu'on cherche est dans le paquetage stats
# e.g. avec distr = "binom" et en mettant size = 5, prob = 0.20 en argument f_X <- dbinom(x = 0:s, size = 5, prob = 0.20)
f_X <- rlang::exec(.fn = paste0("d", distr), x = 0:s, ..., .env = ns_env("stats"))
##  point de départ à 0
f_S[(0) + 1] <- f_X[(0) + 1]^n
##  dans le cas où l'utilisateur spécifie une valeur de s > 0
if ((s) > 0) {
##  donc on commence la récursion à partir de f_Sn(1) jusqu'à f_Sn(s)
for (i in (1):(s)) {
f_S[(i) + 1] <- sum(
sapply(1:(i),
function(j) {
f_X[(j) + 1] * ((n + 1) * ((j) / i) - 1) * f_S[(i - j) + 1]
}
)
) / f_X[(0) + 1]
# f_S[(i) + 1] <- sum(f_X[(1:i) + 1] * f_S[(i - 1:i) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
}
}
# sum(f_X[(1:i) + 1] * f_S[(i - 1:i) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
##  retourne f_Sn(s)
# return(f_S[(s) + 1])
##  retourne toutes les valeurs de f_Sn de 0 à s
return(f_S)
}
DePril_RecursiveDensity(s = 10, n = 10, distr = "binom", size = 5, prob = 0.20)
DePril_RecursiveDensity(s = 10, n = 10, distr = "binom", size = 5, prob = 0.20)
sum(DePril_RecursiveDensity(s = 10, n = 10, distr = "binom", size = 5, prob = 0.20))
sum(recur.nrisks(ff = dbinom(x = 0:10, size = 5, prob = 0.20), nn = 10, smax = 10))
DePril_RecursiveDensity <- function(s, n, distr, ...) {
stopifnot(s >= 0, n > 0, distr %in% c("nbinom", "binom", "geom", "pois", "unif"))
##  R commence les positions des vecteurs à 1 alors que nous commencons lles valeurs à f_Sn(0)
##  donc, il faut ajouter 1 à la valeur de S souhaitée lorsque nous voulons extraire une valeur par l'indice de sa position
f_S <- vector(length = (s) + 1)
##  rlang::exec permet d'exécuter une fonction que l'on défini par morceaux
##  ns_env('stats') fait juste dire à R que la fonction d<distr> qu'on cherche est dans le paquetage stats
# e.g. avec distr = "binom" et en mettant size = 5, prob = 0.20 en argument f_X <- dbinom(x = 0:s, size = 5, prob = 0.20)
f_X <- rlang::exec(.fn = paste0("d", distr), x = 0:s, ..., .env = ns_env("stats"))
##  point de départ à 0
f_S[(0) + 1] <- f_X[(0) + 1]^n
##  dans le cas où l'utilisateur spécifie une valeur de s > 0
if ((s) > 0) {
##  donc on commence la récursion à partir de f_Sn(1) jusqu'à f_Sn(s)
for (i in (1):(s)) {
# f_S[(i) + 1] <- sum(
#     sapply(1:(i),
#            function(j) {
#                f_X[(j) + 1] * ((n + 1) * ((j) / i) - 1) * f_S[(i - j) + 1]
#            }
#     )
# ) / f_X[(0) + 1]
f_S[(i) + 1] <- sum(f_X[(1:i) + 1] * f_S[(i - 1:i) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
}
}
# sum(f_X[(1:i) + 1] * f_S[(i - 1:i) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
##  retourne f_Sn(s)
# return(f_S[(s) + 1])
##  retourne toutes les valeurs de f_Sn de 0 à s
return(f_S)
}
sum(DePril_RecursiveDensity(s = 10, n = 10, distr = "binom", size = 5, prob = 0.20))
sum(recur.nrisks(ff = dbinom(x = 0:10, size = 5, prob = 0.20), nn = 10, smax = 10))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
1:0
s=0
for (i in (1):(s)) {
# f_S[(i) + 1] <- sum(
#     sapply(1:(i),
#            function(j) {
#                f_X[(j) + 1] * ((n + 1) * ((j) / i) - 1) * f_S[(i - j) + 1]
#            }
#     )
# ) / f_X[(0) + 1]
f_S[(i) + 1] <- sum(f_X[(1:i) + 1] * f_S[(i - 1:i) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
}
s=0
f_S
recur.nrisks(ff = dbinom(x = 0:0, size = 5, prob = 0.20), nn = 50, smax = 0)
DePril_RecursiveDensity <- function(s, n, distr, ...) {
stopifnot(s >= 0, n > 0, distr %in% c("nbinom", "binom", "geom", "pois", "unif"))
##  R commence les positions des vecteurs à 1 alors que nous commencons lles valeurs à f_Sn(0)
##  donc, il faut ajouter 1 à la valeur de S souhaitée lorsque nous voulons extraire une valeur par l'indice de sa position
f_S <- vector(length = (s) + 1)
##  rlang::exec permet d'exécuter une fonction que l'on défini par morceaux
##  ns_env('stats') fait juste dire à R que la fonction d<distr> qu'on cherche est dans le paquetage stats
# e.g. avec distr = "binom" et en mettant size = 5, prob = 0.20 en argument f_X <- dbinom(x = 0:s, size = 5, prob = 0.20)
f_X <- rlang::exec(.fn = paste0("d", distr), x = 0:s, ..., .env = ns_env("stats"))
##  point de départ à 0
f_S[(0) + 1] <- f_X[(0) + 1]^n
##  dans le cas où l'utilisateur spécifie une valeur de s > 0
# if ((s) > 0) {
##  donc on commence la récursion à partir de f_Sn(1) jusqu'à f_Sn(s)
for (i in (1):(s)) {
# f_S[(i) + 1] <- sum(
#     sapply(1:(i),
#            function(j) {
#                f_X[(j) + 1] * ((n + 1) * ((j) / i) - 1) * f_S[(i - j) + 1]
#            }
#     )
# ) / f_X[(0) + 1]
f_S[(i) + 1] <- sum(f_X[(1:i) + 1] * f_S[(i - 1:i) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
}
# }
# sum(f_X[(1:i) + 1] * f_S[(i - 1:i) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
##  retourne f_Sn(s)
# return(f_S[(s) + 1])
##  retourne toutes les valeurs de f_Sn de 0 à s
return(f_S)
}
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
DePril_RecursiveDensity <- function(s, n, distr, ...) {
stopifnot(s >= 0, n > 0, distr %in% c("nbinom", "binom", "geom", "pois", "unif"))
##  R commence les positions des vecteurs à 1 alors que nous commencons lles valeurs à f_Sn(0)
##  donc, il faut ajouter 1 à la valeur de S souhaitée lorsque nous voulons extraire une valeur par l'indice de sa position
f_S <- vector(length = (s) + 1)
##  rlang::exec permet d'exécuter une fonction que l'on défini par morceaux
##  ns_env('stats') fait juste dire à R que la fonction d<distr> qu'on cherche est dans le paquetage stats
# e.g. avec distr = "binom" et en mettant size = 5, prob = 0.20 en argument f_X <- dbinom(x = 0:s, size = 5, prob = 0.20)
f_X <- rlang::exec(.fn = paste0("d", distr), x = 0:s, ..., .env = ns_env("stats"))
##  point de départ à 0
f_S[(0) + 1] <- f_X[(0) + 1]^n
##  dans le cas où l'utilisateur spécifie une valeur de s > 0
# if ((s) > 0) {
##  donc on commence la récursion à partir de f_Sn(1) jusqu'à f_Sn(s)
for (i in (1):(s)) {
# f_S[(i) + 1] <- sum(
#     sapply(1:(i),
#            function(j) {
#                f_X[(j) + 1] * ((n + 1) * ((j) / i) - 1) * f_S[(i - j) + 1]
#            }
#     )
# ) / f_X[(0) + 1]
f_S[(i) + 1] <- sum(f_X[(1:i) + 1] * f_S[(i - 1:i) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
}
# }
# sum(f_X[(1:i) + 1] * f_S[(i - 1:i) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
##  retourne f_Sn(s)
# return(f_S[(s) + 1])
##  retourne toutes les valeurs de f_Sn de 0 à s
return(f_S)
}
DePril_RecursiveDensity <- function(s, n, distr, ...) {
stopifnot(s >= 0, n > 0, distr %in% c("nbinom", "binom", "geom", "pois", "unif"))
##  R commence les positions des vecteurs à 1 alors que nous commencons lles valeurs à f_Sn(0)
##  donc, il faut ajouter 1 à la valeur de S souhaitée lorsque nous voulons extraire une valeur par l'indice de sa position
f_S <- vector(length = (s) + 1)
##  rlang::exec permet d'exécuter une fonction que l'on défini par morceaux
##  ns_env('stats') fait juste dire à R que la fonction d<distr> qu'on cherche est dans le paquetage stats
# e.g. avec distr = "binom" et en mettant size = 5, prob = 0.20 en argument f_X <- dbinom(x = 0:s, size = 5, prob = 0.20)
f_X <- rlang::exec(.fn = paste0("d", distr), x = 0:s, ..., .env = ns_env("stats"))
##  point de départ à 0
f_S[(0) + 1] <- f_X[(0) + 1]^n
##  dans le cas où l'utilisateur spécifie une valeur de s > 0
# if ((s) > 0) {
##  donc on commence la récursion à partir de f_Sn(1) jusqu'à f_Sn(s)
for (i in (1):(s)) {
# f_S[(i) + 1] <- sum(
#     sapply(1:(i),
#            function(j) {
#                f_X[(j) + 1] * ((n + 1) * ((j) / i) - 1) * f_S[(i - j) + 1]
#            }
#     )
# ) / f_X[(0) + 1]
f_S[(i) + 1] <- sum(f_X[(1:i) + 1] * f_S[(i - 1:i) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
}
# }
# sum(f_X[(1:i) + 1] * f_S[(i - 1:i) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
##  retourne f_Sn(s)
return(f_S[(s) + 1])
##  retourne toutes les valeurs de f_Sn de 0 à s
# return(f_S)
}
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20)
recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500)
sum(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
DePril_RecursiveDensity <- function(s, n, distr, ...) {
stopifnot(s >= 0, n > 0, distr %in% c("nbinom", "binom", "geom", "pois", "unif"))
##  R commence les positions des vecteurs à 1 alors que nous commencons lles valeurs à f_Sn(0)
##  donc, il faut ajouter 1 à la valeur de S souhaitée lorsque nous voulons extraire une valeur par l'indice de sa position
f_S <- vector(length = (s) + 1)
##  rlang::exec permet d'exécuter une fonction que l'on défini par morceaux
##  ns_env('stats') fait juste dire à R que la fonction d<distr> qu'on cherche est dans le paquetage stats
# e.g. avec distr = "binom" et en mettant size = 5, prob = 0.20 en argument f_X <- dbinom(x = 0:s, size = 5, prob = 0.20)
f_X <- rlang::exec(.fn = paste0("d", distr), x = 0:s, ..., .env = ns_env("stats"))
##  point de départ à 0
f_S[(0) + 1] <- f_X[(0) + 1]^n
##  dans le cas où l'utilisateur spécifie une valeur de s > 0
# if ((s) > 0) {
##  donc on commence la récursion à partir de f_Sn(1) jusqu'à f_Sn(s)
for (i in (1):(s)) {
# f_S[(i) + 1] <- sum(
#     sapply(1:(i),
#            function(j) {
#                f_X[(j) + 1] * ((n + 1) * ((j) / i) - 1) * f_S[(i - j) + 1]
#            }
#     )
# ) / f_X[(0) + 1]
f_S[(i) + 1] <- sum(f_X[(1:i) + 1] * f_S[(i - 1:i) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
}
# }
# sum(f_X[(1:i) + 1] * f_S[(i - 1:i) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
##  retourne f_Sn(s)
# return(f_S[(s) + 1])
##  retourne toutes les valeurs de f_Sn de 0 à s
return(f_S)
}
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
DePril_RecursiveDensity <- function(s, n, distr, ...) {
stopifnot(s >= 0, n > 0, distr %in% c("nbinom", "binom", "geom", "pois", "unif"))
##  R commence les positions des vecteurs à 1 alors que nous commencons lles valeurs à f_Sn(0)
##  donc, il faut ajouter 1 à la valeur de S souhaitée lorsque nous voulons extraire une valeur par l'indice de sa position
f_S <- vector(length = (s) + 1)
##  rlang::exec permet d'exécuter une fonction que l'on défini par morceaux
##  ns_env('stats') fait juste dire à R que la fonction d<distr> qu'on cherche est dans le paquetage stats
# e.g. avec distr = "binom" et en mettant size = 5, prob = 0.20 en argument f_X <- dbinom(x = 0:s, size = 5, prob = 0.20)
f_X <- rlang::exec(.fn = paste0("d", distr), x = 0:s, ..., .env = ns_env("stats"))
##  point de départ à 0
f_S[(0) + 1] <- f_X[(0) + 1]^n
##  dans le cas où l'utilisateur spécifie une valeur de s > 0
if ((s) > 0) {
##  donc on commence la récursion à partir de f_Sn(1) jusqu'à f_Sn(s)
for (i in (1):(s)) {
# f_S[(i) + 1] <- sum(
#     sapply(1:(i),
#            function(j) {
#                f_X[(j) + 1] * ((n + 1) * ((j) / i) - 1) * f_S[(i - j) + 1]
#            }
#     )
# ) / f_X[(0) + 1]
f_S[(i) + 1] <- sum(f_X[(1:i) + 1] * f_S[(i - 1:i) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
}
}
##  retourne f_Sn(s)
# return(f_S[(s) + 1])
##  retourne toutes les valeurs de f_Sn de 0 à s
return(f_S)
}
sum(DePril_RecursiveDensity(s = 10, n = 10, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
((s) > 0)
(s > 0)
s=1
(s > 0)
((s) > 0)
DePril_RecursiveDensity <- function(s, n, distr, ...) {
stopifnot(s >= 0, n > 0, distr %in% c("nbinom", "binom", "geom", "pois", "unif"))
##  R commence les positions des vecteurs à 1 alors que nous commencons lles valeurs à f_Sn(0)
##  donc, il faut ajouter 1 à la valeur de S souhaitée lorsque nous voulons extraire une valeur par l'indice de sa position
f_S <- vector(length = (s) + 1)
##  rlang::exec permet d'exécuter une fonction que l'on défini par morceaux
##  ns_env('stats') fait juste dire à R que la fonction d<distr> qu'on cherche est dans le paquetage stats
# e.g. avec distr = "binom" et en mettant size = 5, prob = 0.20 en argument f_X <- dbinom(x = 0:s, size = 5, prob = 0.20)
f_X <- rlang::exec(.fn = paste0("d", distr), x = 0:s, ..., .env = ns_env("stats"))
##  point de départ à 0
f_S[(0) + 1] <- f_X[(0) + 1]^n
##  dans le cas où l'utilisateur spécifie une valeur de s > 0
if ((s) > 0) {
##  donc on commence la récursion à partir de f_Sn(1) jusqu'à f_Sn(s)
for (i in (1):(s)) {
# f_S[(i) + 1] <- sum(
#     sapply(1:(i),
#            function(j) {
#                f_X[(j) + 1] * ((n + 1) * ((j) / i) - 1) * f_S[(i - j) + 1]
#            }
#     )
# ) / f_X[(0) + 1]
f_S[(i) + 1] <- sum(f_X[(1:i) + 1] * f_S[(i - 1:i) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
}
}
##  retourne f_Sn(s)
# return(f_S[(s) + 1])
##  retourne toutes les valeurs de f_Sn de 0 à s
return(f_S)
}
sum(DePril_RecursiveDensity(s = 10, n = 10, distr = "binom", size = 5, prob = 0.20))
sum(recur.nrisks(ff = dbinom(x = 0:10, size = 5, prob = 0.20), nn = 10, smax = 10))
sum(DePril_RecursiveDensity(s = 120, n = 10, distr = "binom", size = 5, prob = 0.20))
sum(recur.nrisks(ff = dbinom(x = 0:120, size = 5, prob = 0.20), nn = 10, smax = 120))
sum(DePril_RecursiveDensity(s = 10, n = 10, distr = "binom", size = 5, prob = 0.20))
sum(recur.nrisks(ff = dbinom(x = 0:10, size = 5, prob = 0.20), nn = 10, smax = 10))
DePril_RecursiveDensity <- function(s, n, distr, ...) {
stopifnot(s >= 0, n > 0, distr %in% c("nbinom", "binom", "geom", "pois", "unif"))
##  R commence les positions des vecteurs à 1 alors que nous commencons lles valeurs à f_Sn(0)
##  donc, il faut ajouter 1 à la valeur de S souhaitée lorsque nous voulons extraire une valeur par l'indice de sa position
f_S <- vector(length = (s) + 1)
##  rlang::exec permet d'exécuter une fonction que l'on défini par morceaux
##  ns_env('stats') fait juste dire à R que la fonction d<distr> qu'on cherche est dans le paquetage stats
# e.g. avec distr = "binom" et en mettant size = 5, prob = 0.20 en argument f_X <- dbinom(x = 0:s, size = 5, prob = 0.20)
f_X <- rlang::exec(.fn = paste0("d", distr), x = 0:s, ..., .env = ns_env("stats"))
##  point de départ à 0
f_S[(0) + 1] <- f_X[(0) + 1]^n
##  dans le cas où l'utilisateur spécifie une valeur de s > 0
if ((s) > 0) {
##  donc on commence la récursion à partir de f_Sn(1) jusqu'à f_Sn(s)
for (i in (1):(s)) {
##  avec un sapply
# f_S[(i) + 1] <- sum(
#     sapply(1:(i),
#            function(j) {
#                f_X[(j) + 1] * ((n + 1) * ((j) / i) - 1) * f_S[(i - j) + 1]
#            }
#     )
# ) / f_X[(0) + 1]
##  avec multiplication de matrices directement
f_S[(i) + 1] <- sum(f_X[(1:i) + 1] * f_S[((i - 1):1) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
}
}
##  retourne f_Sn(s)
# return(f_S[(s) + 1])
##  retourne toutes les valeurs de f_Sn de 0 à s
return(f_S)
}
sum(DePril_RecursiveDensity(s = 10, n = 10, distr = "binom", size = 5, prob = 0.20))
DePril_RecursiveDensity <- function(s, n, distr, ...) {
stopifnot(s >= 0, n > 0, distr %in% c("nbinom", "binom", "geom", "pois", "unif"))
##  R commence les positions des vecteurs à 1 alors que nous commencons lles valeurs à f_Sn(0)
##  donc, il faut ajouter 1 à la valeur de S souhaitée lorsque nous voulons extraire une valeur par l'indice de sa position
f_S <- vector(length = (s) + 1)
##  rlang::exec permet d'exécuter une fonction que l'on défini par morceaux
##  ns_env('stats') fait juste dire à R que la fonction d<distr> qu'on cherche est dans le paquetage stats
# e.g. avec distr = "binom" et en mettant size = 5, prob = 0.20 en argument f_X <- dbinom(x = 0:s, size = 5, prob = 0.20)
f_X <- rlang::exec(.fn = paste0("d", distr), x = 0:s, ..., .env = ns_env("stats"))
##  point de départ à 0
f_S[(0) + 1] <- f_X[(0) + 1]^n
##  dans le cas où l'utilisateur spécifie une valeur de s > 0
if ((s) > 0) {
##  donc on commence la récursion à partir de f_Sn(1) jusqu'à f_Sn(s)
for (i in (1):(s)) {
##  avec un sapply
# f_S[(i) + 1] <- sum(
#     sapply(1:(i),
#            function(j) {
#                f_X[(j) + 1] * ((n + 1) * ((j) / i) - 1) * f_S[(i - j) + 1]
#            }
#     )
# ) / f_X[(0) + 1]
##  avec multiplication de matrices directement
f_S[(i) + 1] <- sum(f_X[(1:i) + 1] * f_S[(i:1) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
}
}
##  retourne f_Sn(s)
# return(f_S[(s) + 1])
##  retourne toutes les valeurs de f_Sn de 0 à s
return(f_S)
}
sum(DePril_RecursiveDensity(s = 10, n = 10, distr = "binom", size = 5, prob = 0.20))
sum(recur.nrisks(ff = dbinom(x = 0:10, size = 5, prob = 0.20), nn = 10, smax = 10))
i=5
(i - (1:i)) + 1
i:1
(i - 1):0
(i - 1):0 +1
DePril_RecursiveDensity <- function(s, n, distr, ...) {
stopifnot(s >= 0, n > 0, distr %in% c("nbinom", "binom", "geom", "pois", "unif"))
##  R commence les positions des vecteurs à 1 alors que nous commencons lles valeurs à f_Sn(0)
##  donc, il faut ajouter 1 à la valeur de S souhaitée lorsque nous voulons extraire une valeur par l'indice de sa position
f_S <- vector(length = (s) + 1)
##  rlang::exec permet d'exécuter une fonction que l'on défini par morceaux
##  ns_env('stats') fait juste dire à R que la fonction d<distr> qu'on cherche est dans le paquetage stats
# e.g. avec distr = "binom" et en mettant size = 5, prob = 0.20 en argument f_X <- dbinom(x = 0:s, size = 5, prob = 0.20)
f_X <- rlang::exec(.fn = paste0("d", distr), x = 0:s, ..., .env = ns_env("stats"))
##  point de départ à 0
f_S[(0) + 1] <- f_X[(0) + 1]^n
##  dans le cas où l'utilisateur spécifie une valeur de s > 0
if ((s) > 0) {
##  donc on commence la récursion à partir de f_Sn(1) jusqu'à f_Sn(s)
for (i in (1):(s)) {
##  avec un sapply
# f_S[(i) + 1] <- sum(
#     sapply(1:(i),
#            function(j) {
#                f_X[(j) + 1] * ((n + 1) * ((j) / i) - 1) * f_S[(i - j) + 1]
#            }
#     )
# ) / f_X[(0) + 1]
##  avec multiplication de matrices directement
f_S[(i) + 1] <- sum(f_X[(1:i) + 1] * f_S[((i - 1):0) + 1] * ((n + 1) * ((1:i)) / i - 1)) / f_X[(0) + 1]
}
}
##  retourne f_Sn(s)
# return(f_S[(s) + 1])
##  retourne toutes les valeurs de f_Sn de 0 à s
return(f_S)
}
sum(DePril_RecursiveDensity(s = 10, n = 10, distr = "binom", size = 5, prob = 0.20))
sum(recur.nrisks(ff = dbinom(x = 0:10, size = 5, prob = 0.20), nn = 10, smax = 10))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
system.time(DePril_RecursiveDensity(s = 500, n = 50, distr = "binom", size = 5, prob = 0.20))
system.time(recur.nrisks(ff = dbinom(x = 0:500, size = 5, prob = 0.20), nn = 50, smax = 500))
