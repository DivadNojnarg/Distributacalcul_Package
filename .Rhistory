x <- 4
for (k in seq_len(x)) {
f_s[k] <- (
sum(sapply(1:k, function(j) {
dbinom(x = j, size = distr.param$size, prob = distr.param$prob) *
f_s[(k - j) + 1] *
((m + 1) * (j/k) - 1)
}))
) / dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)
}
return(f_s[x+ 1])
x <- 4
f_s <- vector(length = x)
f_s
x <- 4
f_s <- vector(length = x + 1)
f_s[0] <- dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)^m
f_s[1] <- dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)^m
f_s
for (k in seq_len(x)) {
f_s[k] <- (
sum(sapply(1:k, function(j) {
dbinom(x = j, size = distr.param$size, prob = distr.param$prob) *
f_s[(k - j) + 1] *
((m + 1) * (j/k) - 1)
}))
) / dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)
}
return(f_s[x+ 1])
f_s[x+ 1]
f_s
dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)^m
0.000014
x <- 4
f_s <- vector(length = x + 1)
f_s[1] <- dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)^m
for (k in seq_len(x)) {
f_s[k + 1] <- (
sum(sapply(1:k, function(j) {
dbinom(x = j, size = distr.param$size, prob = distr.param$prob) *
f_s[(k - j) + 1] *
((m + 1) * (j/k) - 1)
}))
) / dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)
}
return(f_s[x+ 1])
f_s[x+ 1]
TVaR_exp(kap = 0.9, rate = 1)
library(Distributacalcul)
TVaR_exp(kap = 0.9, rate = 1)
TVaR_gamma(kap = 0.9, rate = 1, shape = 2)
TVaR_gamma(kap = 0.99, rate = 1, shape = 2)
TVaR_gamma(kap = 0.34, rate = 1, shape = 2)
library(Distributacalcul)
library(Distributacalcul)
library(Distributacalcul)
E_lnorm
2 %% 1
2 %% 1 == 0
3 %% 1 == 0
3 %% 1
3 %% 2
4 %% 2
5 %% 2
5 %% 2 == 0
is.integer(5)
5 %% 2 == 0
5 %% 2
4 %% 2
4.4 %% 2
5.4 %% 2
5.4 %% 1
5 %% 1
4 %% 1
3 %% 1
4.2 %% 1
Elim_erlang(d = 2, shape = 2, rate = 0.2)
#' @export
#'
#' @examples
#'
#' # With scale parameter
#' perlang(q = 2, shape = 2, scale = 5)
#'
#' # With rate parameter
#' perlang(q = 2, shape = 2, rate = 0.2)
#'
perlang <- function(q, shape, scale = 1 / rate, rate = 1 / scale, lower.tail = TRUE)
{
stopifnot(q >= 0, shape %% 1 == 0, rate > 0)
Fx <- exp(-rate * q) *
sum(sapply(0:(shape - 1), function(j) ((rate * q)^j) / factorial(j)))
if (lower.tail == T) {
(1 - Fx)
} else {
Fx
}
}
perlang(q = 2, shape = 2, rate = 0.2)
#'  parameter \eqn{n} and rate parameter \eqn{\beta}{beta}.
#'
#' @templateVar kap TRUE
#' @templateVar vark TRUE
#' @templateVar q FALSE
#' @template erlang-template
#'
#' @details This formula needs the formula for the VaR_erlang (already installed with the tvarPackage).
#'
#' @export
.TVaR_erlang <- function(kap, shape, scale = 1 / rate, rate = 1 / scale, vark)
{
stopifnot(kap >= 0, kap <= 1, shape %% 1 == 0, rate > 0)
(shape / ((1 - kap) * rate)) *
(exp(-rate * vark) *
sum(sapply(0:shape, function(j) ((rate * vark)^j)/factorial(j)))
)
}
#' @importFrom stats pgamma
#'
#' @examples
#'
#' # With scale parameter
#' Mexcess_erlang(d = 2, shape = 2, scale = 5)
#'
#' # With rate parameter
#' Mexcess_erlang(d = 2, shape = 2, rate = 0.2)
#'
Mexcess_erlang <- function(d, shape, scale = 1 / rate, rate = 1 / scale)
{
stopifnot(d >= 0, shape %% 1 == 0, rate > 0)
(shape / rate) *
pgamma(q = d, shape = shape + 1, rate = rate, lower.tail = F) /
pgamma(q = d, shape = shape, rate = rate, lower.tail = F) -
d
}
Mexcess_erlang(d = 2, shape = 2, rate = 0.2)
Mexcess_erlang(d = 2, shape = 2, scale = 5)
Mexcess_erlang(d = 2, shape = 3, scale = 5)
Mexcess_erlang(d = 2, shape = 3.5, scale = 5)
#' @export
#'
#' @examples
#'
#' # With scale parameter
#' Mexcess_exp(d = 2, scale = 4)
#'
#' # With rate parameter
#' Mexcess_exp(d = 5, rate = 0.25)
#'
Mexcess_exp <- function(d, rate = 1 / scale, scale = 1 / rate) {
stopifnot(d >= 0, rate > 0)
E_exp(rate)
}
Mexcess_exp(d = 5, rate = 0.25)
#' @importFrom stats pgamma
#'
#' @examples
#'
#' # With scale parameter
#' Mexcess_erlang(d = 2, shape = 2, scale = 5)
#'
#' # With rate parameter
#' Mexcess_erlang(d = 2, shape = 2, rate = 0.2)
#'
Mexcess_erlang <- function(d, shape, scale = 1 / rate, rate = 1 / scale)
{
stopifnot(d >= 0, shape %% 1 == 0, rate > 0)
(shape / rate) *
pgamma(q = d, shape = shape + 1, rate = rate, lower.tail = F) /
pgamma(q = d, shape = shape, rate = rate, lower.tail = F) -
d
}
Mexcess_erlang(d = 2, shape = 2, rate = 0.2)
#' @export
#'
#' @examples
#'
#' # With scale parameter
#' Mexcess_burr(d = 2, rate = 2, shape1 = 2, shape2 = 5)
#'
#' # With rate parameter
#' Mexcess_burr(d = 2, scale = 0.5, shape1 = 2, shape2 = 5)
#'
Mexcess_burr <- function(d, shape1, shape2, rate = 1 / scale, scale = 1 / rate) {
stopifnot(shape1 > 0, shape2 > 0, rate > 0, d >= 0)
(
((rate + d^shape2)^shape1) *
gamma(1 + 1/shape2) *
gamma(shape1 - 1/shape2)
) / (
(rate ^ (shape1 - 1/shape2)) *
gamma(shape1)
) *
pbeta(
q = (d^shape2) / (rate + (d^shape2)),
shape1 = 1 + 1/shape2,
shape2 = shape1 - 1/shape2,
lower.tail = F) -
d
}
Mexcess_burr(d = 2, scale = 0.5, shape1 = 2, shape2 = 5)
Mexcess_burr(d = 2, rate = 2, shape1 = 2, shape2 = 5)
library(Distributacalcul)
devtools::load_all("~/OneDrive - Université Laval/Packages/Distributacalcul")
source('~/OneDrive - Université Laval/Packages/Distributacalcul/R/TVaR_PCOMP.R', echo=TRUE)
#' Mean excess loss (excès-moyen) d'une loi inverse gaussienne
#' @param d déductible
#' @param mu mu
#' @param beta beta = dispersion * mu^2
#' @param dispersion dispersion = beta / mu^2
#' @export
#' @importFrom stats pnorm
Mexcess_IG <- function(d, mu, beta = dispersion * mu^2, dispersion = beta / mu^2)
{
stopifnot(d >= 0, mu >= 0, beta >= 0)
((mu - d) * stats::pnorm((d - mu) * sqrt(1 / (beta * d)), lower.tail = F) +
(d + mu) * exp((2 * mu) / beta) * stats::pnorm(-(d + mu) * sqrt(1 / (beta * d))))/ (1 - (stats::pnorm(sqrt(1/(beta * d)) * (d - mu)) + exp((2 * mu) / beta) * stats::pnorm(-sqrt(1/(beta * d)) * (d + mu))))
}
#' @param rate beta pour la Gamma et sigma^2 pour la lognormale
#' @param distr_severity choice of severity distribution Gamma (default) or Lognormal
#'
#' @examples
#'
#' E_BNCOMP(size = 4, prob = 0.2, shape = 0, rate = 1, distr_severity = "Lognormal")
#' E_BNCOMP(size = 4, prob = 0.4, shape = 0, rate = 2, distr_severity = "lognormal")
#'
#' @export
#'
E_BNCOMP <- function(size, prob, shape, rate, distr_severity = "Gamma")
{
stopifnot(prob >= 0, prob <= 1, rate > 0)
stopifnot(grepl(pattern = "(^Gamma$)|(^Lognormal[e]*$)", x = distr_severity, ignore.case = TRUE))
if (grepl(pattern = "^Gamma$", x = distr_severity, ignore.case = TRUE)) {
E.NBCOMP <- E_negbinom(size, prob, nb_tries = FALSE) * kthmoment_gamma(k = 1, shape, rate)
} else if (grepl(pattern = "^Lognormal[e]*$", x = distr_severity, ignore.case = TRUE)) {
E.NBCOMP <- E_negbinom(size, prob, nb_tries = FALSE) * E_lnorm(shape, sqrt(rate))
} else {
stop("Please enter a valid distribution choice. Either 'Lognormal' or 'Gamma'")
}
return(E.NBCOMP)
}
E_BNCOMP(size = 4, prob = 0.2, shape = 0, rate = 1, distr_severity = "Lognormal")
#'
#' # Where k is the number of trials for a rth success
#' E_negbinom(r = 2, p = .4)
#'
#' # Where k is the number of failures before a rth success
#' E_negbinom(r = 2, p = .4, nb_tries = TRUE)
#'
#' # With alternative parameterization where k is the number of trials
#' E_negbinom(r = 2, beta = 1.5)
#'
E_negbinom <- function(r, p = (1 / (1 + beta)), beta = ((1 - p) / p), nb_tries = F)
{
if (nb_tries) {
r / p
} else {
r * ((1 - p) / p)
}
}
E_negbinom(r = 2, beta = 1.5)
#' @param rate beta pour la Gamma et sigma^2 pour la lognormale
#' @param distr_severity choice of severity distribution Gamma (default) or Lognormal
#'
#' @examples
#'
#' E_BNCOMP(size = 4, prob = 0.2, shape = 0, rate = 1, distr_severity = "Lognormal")
#' E_BNCOMP(size = 4, prob = 0.4, shape = 0, rate = 2, distr_severity = "lognormal")
#'
#' @export
#'
E_BNCOMP <- function(size, prob, shape, rate, distr_severity = "Gamma")
{
stopifnot(prob >= 0, prob <= 1, rate > 0)
stopifnot(grepl(pattern = "(^Gamma$)|(^Lognormal[e]*$)", x = distr_severity, ignore.case = TRUE))
if (grepl(pattern = "^Gamma$", x = distr_severity, ignore.case = TRUE)) {
E.NBCOMP <- E_negbinom(size, prob, nb_tries = FALSE) * kthmoment_gamma(k = 1, shape, rate)
} else if (grepl(pattern = "^Lognormal[e]*$", x = distr_severity, ignore.case = TRUE)) {
E.NBCOMP <- E_negbinom(size, prob, nb_tries = FALSE) * E_lnorm(shape, sqrt(rate))
} else {
stop("Please enter a valid distribution choice. Either 'Lognormal' or 'Gamma'")
}
return(E.NBCOMP)
}
E_BNCOMP(size = 4, prob = 0.4, shape = 0, rate = 2, distr_severity = "lognormal")
#' Espérance tronquée d'une loi uniforme
#' @param a minimum
#' @param b maximum
#' @param d cut-off value
#' @export
Etronq_unif <- function(d,a, b) (d^2 -a^2) / (2*(b-a))
source('~/OneDrive - Université Laval/Packages/Distributacalcul/R/Etronq_unif.R', echo=TRUE)
#' p_negbinom(k = 3, r = 2, p = .4, nb_tries = TRUE)
#'
#' # By definition, k must be greater than r.
#' \dontrun{
#'  p_negbinom(k = 1, r = 2, p = .4, nb_tries = TRUE)
#' }
#'
#' # With alternative parameterization where k is the number of trials
#' p_negbinom(k = 3, r = 2, beta = 1.5)
#'
p_negbinom <- function(k, r, p = (1 / (1 + beta)), beta = ((1 - p) / p), nb_tries = FALSE, lower.tail = TRUE){
p_negbinom(k = 3, r = 2, beta = 1.5)
p_negbinom <- function(k, r, p = (1 / (1 + beta)), beta = ((1 - p) / p), nb_tries = FALSE, lower.tail = TRUE){
if (nb_tries) {
stopifnot(k > r)
}
start_FX <- ifelse(nb_tries, r, 0)
if (lower.tail) {
sum(sapply(start_FX:k, function(i) d_negbinom(k = i, r = r, p = p, nb_tries = nb_tries)))
} else {
1 - sum(sapply(start_FX:k, function(i) d_negbinom(k = i, r = r, p = p, nb_tries = nb_tries)))
}
}
p_negbinom(k = 3, r = 2, beta = 1.5)
library(Distributacalcul)
devtools::install_github("alec42/Distributacalcul_Package")
cont.distr.support %>%
as.data.frame() %>%
rownames_to_column('names') %>%
mutate_if(is.list, ~ifelse(. == T, "X", "")) %>%
column_to_rownames('names') %>%
pander::pander()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%"
)
library(tidyverse)
library(Distributacalcul)
##  Various moments:
E_beta(shape1 = 2, shape2 = 4) # E[X]
V_beta(shape1 = 2, shape2 = 4) # V(X)
kthmoment_beta(k = 3, shape1 = 2, shape2 = 4) # E[X^k]
##  Expected value of functions:
Elim_beta(d = 0.3, shape1 = 2, shape2 = 4) # E[min(X; d)]
Etronq_beta(d = .3, shape1 = 2, shape2 = 4, less.than.d = TRUE) # E[X * 1_{X <= d}]
Etronq_beta(d = .3, shape1 = 2, shape2 = 4, less.than.d = FALSE) # E[X * 1_{X > d}]
Mexcess_beta(d = .3, shape1 = 2, shape2 = 4) # E[(X - d | X > d)]
SL_beta(d = .3, shape1 = 2, shape2 = 4) # E[max(X - d, 0)]
##  Risk measures:
TVaR_beta(kap = 0.99, shape1 = 2, shape2 = 4) # TVaR_{k}(X)
VaR_beta(kap = 0.99, shape1 = 2, shape2 = 4) # VaR_{k}(X) = F_X^(-1)(k)
cont.distr.support <- cbind(
Erlang = list(`Mean` = T, `kth moment` = T, `Variance` = T,
`Truncated mean` = T, `Limited mean` = T,  `Stop-loss` = T, `Excess of mean` = T,
`Moment Generating Function` = F,
`Probability Density Function` = T, `Cumulative Probability Density Function` = T,
`Value-at-Risk` = F, `Tail Value-at-Risk` = T
),
`Inverse Gaussian` = list(`Mean` = T, `kth moment` = F, `Variance` = T,
`Truncated mean` = T, `Limited mean` = T,  `Stop-loss` = T, `Excess of mean` = T,
`Moment Generating Function` = T,
`Probability Density Function` = T, `Cumulative Probability Density Function` = T,
`Value-at-Risk` = T, `Tail Value-at-Risk` = T
),
`Weibull` = list(`Mean` = T, `kth moment` = T, `Variance` = T,
`Truncated mean` = T, `Limited mean` = T,  `Stop-loss` = T, `Excess of mean` = T,
`Moment Generating Function` = F,
`Probability Density Function` = F, `Cumulative Probability Density Function` = F,
`Value-at-Risk` = T, `Tail Value-at-Risk` = T
),
`Burr` = list(`Mean` = T, `kth moment` = T, `Variance` = T,
`Truncated mean` = T, `Limited mean` = T,  `Stop-loss` = T, `Excess of mean` = T,
`Moment Generating Function` = F,
`Probability Density Function` = F, `Cumulative Probability Density Function` = F,
`Value-at-Risk` = T, `Tail Value-at-Risk` = T
),
`Log-logistic` = list(`Mean` = T, `kth moment` = T, `Variance` = T,
`Truncated mean` = T, `Limited mean` = T,  `Stop-loss` = T, `Excess of mean` = T,
`Moment Generating Function` = F,
`Probability Density Function` = F, `Cumulative Probability Density Function` = F,
`Value-at-Risk` = T, `Tail Value-at-Risk` = T
),
`Beta` = list(`Mean` = T, `kth moment` = T, `Variance` = T,
`Truncated mean` = T, `Limited mean` = T,  `Stop-loss` = T, `Excess of mean` = T,
`Moment Generating Function` = F,
`Probability Density Function` = F, `Cumulative Probability Density Function` = F,
`Value-at-Risk` = T, `Tail Value-at-Risk` = T
),
`Gamma` = list(`Mean` = T, `kth moment` = T, `Variance` = T,
`Truncated mean` = T, `Limited mean` = T,  `Stop-loss` = T, `Excess of mean` = T,
`Moment Generating Function` = F,
`Probability Density Function` = F, `Cumulative Probability Density Function` = F,
`Value-at-Risk` = T, `Tail Value-at-Risk` = T
),
`Pareto` = list(`Mean` = T, `kth moment` = T, `Variance` = T,
`Truncated mean` = T, `Limited mean` = T,  `Stop-loss` = T, `Excess of mean` = T,
`Moment Generating Function` = F,
`Probability Density Function` = F, `Cumulative Probability Density Function` = F,
`Value-at-Risk` = T, `Tail Value-at-Risk` = T
),
`Generalized F-distribution` = list(`Mean` = F, `kth moment` = F, `Variance` = F,
`Truncated mean` = F, `Limited mean` = F,  `Stop-loss` = F, `Excess of mean` = F,
`Moment Generating Function` = F,
`Probability Density Function` = F, `Cumulative Probability Density Function` = T,
`Value-at-Risk` = T, `Tail Value-at-Risk` = F
),
`Lognormal` = list(`Mean` = T, `kth moment` = T, `Variance` = T,
`Truncated mean` = T, `Limited mean` = T,  `Stop-loss` = T, `Excess of mean` = T,
`Moment Generating Function` = F,
`Probability Density Function` = F, `Cumulative Probability Density Function` = F,
`Value-at-Risk` = T, `Tail Value-at-Risk` = T
),
`Exponential` = list(`Mean` = T, `kth moment` = T, `Variance` = T,
`Truncated mean` = T, `Limited mean` = T,  `Stop-loss` = T, `Excess of mean` = T,
`Moment Generating Function` = F,
`Probability Density Function` = F, `Cumulative Probability Density Function` = F,
`Value-at-Risk` = T, `Tail Value-at-Risk` = T
),
`Uniform` = list(`Mean` = T, `kth moment` = T, `Variance` = T,
`Truncated mean` = T, `Limited mean` = T,  `Stop-loss` = T, `Excess of mean` = T,
`Moment Generating Function` = F,
`Probability Density Function` = F, `Cumulative Probability Density Function` = F,
`Value-at-Risk` = T, `Tail Value-at-Risk` = T
),
`Normal` = list(`Mean` = F, `kth moment` = F, `Variance` = F,
`Truncated mean` = T, `Limited mean` = T,  `Stop-loss` = T, `Excess of mean` = T,
`Moment Generating Function` = F,
`Probability Density Function` = F, `Cumulative Probability Density Function` = F,
`Value-at-Risk` = T, `Tail Value-at-Risk` = T
)
)
cont.distr.support %>%
as.data.frame() %>%
rownames_to_column('names') %>%
mutate_if(is.list, ~ifelse(. == T, "X", "")) %>%
column_to_rownames('names') %>%
pander::pander()
discr.distr.support <- cbind(
`Binomial` = list(`Mean` = T, `kth moment` = F, `Variance` = T,
`Truncated mean` = T, `Limited mean` = F,  `Stop-loss` = F, `Excess of mean` = F,
`Moment Generating Function` = T, `Probability Generating Function` = T,
`Probability Density Function` = F, `Cumulative Probability Density Function` = F,
`Value-at-Risk` = T, `Tail Value-at-Risk` = T
),
`Negative Binomial` = list(`Mean` = F, `kth moment` = F, `Variance` = F,
`Truncated mean` = T, `Limited mean` = F,  `Stop-loss` = F, `Excess of mean` = F,
`Moment Generating Function` = F, `Probability Generating Function` = F,
`Probability Density Function` = F, `Cumulative Probability Density Function` = F,
`Value-at-Risk` = F, `Tail Value-at-Risk` = T
),
`Poisson` = list(`Mean` = T, `kth moment` = F, `Variance` = T,
`Truncated mean` = T, `Limited mean` = F,  `Stop-loss` = F, `Excess of mean` = F,
`Moment Generating Function` = T, `Probability Generating Function` = T,
`Probability Density Function` = F, `Cumulative Probability Density Function` = F,
`Value-at-Risk` = T, `Tail Value-at-Risk` = T
),
`Uniform` = list(`Mean` = T, `kth moment` = F, `Variance` = T,
`Truncated mean` = F, `Limited mean` = F,  `Stop-loss` = F, `Excess of mean` = F,
`Moment Generating Function` = F, `Probability Generating Function` = F,
`Probability Density Function` = T, `Cumulative Probability Density Function` = T,
`Value-at-Risk` = F, `Tail Value-at-Risk` = F
),
`Logarithmic` = list(`Mean` = T, `kth moment` = F, `Variance` = T,
`Truncated mean` = F, `Limited mean` = F,  `Stop-loss` = F, `Excess of mean` = F,
`Moment Generating Function` = F, `Probability Generating Function` = F,
`Probability Density Function` = F, `Cumulative Probability Density Function` = F,
`Value-at-Risk` = F, `Tail Value-at-Risk` = F
),
`Hypergeometric` = list(`Mean` = T, `kth moment` = F, `Variance` = T,
`Truncated mean` = F, `Limited mean` = F,  `Stop-loss` = F, `Excess of mean` = F,
`Moment Generating Function` = F, `Probability Generating Function` = F,
`Probability Density Function` = F, `Cumulative Probability Density Function` = F,
`Value-at-Risk` = F, `Tail Value-at-Risk` = F
)
)
discr.distr.support %>%
as.data.frame() %>%
mutate_all(~ifelse(. == T, "X", "")) %>%
pander::pander()
cont.distr.support %>%
as.data.frame() %>%
rownames_to_column('names') %>%
mutate_if(is.list, ~ifelse(. == T, "X", "")) %>%
column_to_rownames('names') %>%
pander::pander()
cont.distr.support %>%
as.data.frame() %>%
rownames_to_column('names') %>%
mutate_if(is.list, ~ifelse(. == T, "X", "")) %>%
column_to_rownames('names') %>%
pander::pander()
discr.distr.support %>%
as.data.frame() %>%
rownames_to_column('names') %>%
mutate_if(is.list, ~ifelse(. == T, "X", "")) %>%
column_to_rownames('names') %>%
pander::pander()
use_usethis()
usethis::edit_r_environ()
usethis::edit_r_environ()
usethis::edit_r_environ()
usethis::edit_git_config()
usethis::edit_git_ignore()
source('~/OneDrive - Université Laval/Packages/Distributacalcul/R/VaR_gamma.R', echo=TRUE)
VaR_gamma(kap = .2, shape = 3, rate = 0.25)
VaR_gamma(kap = .2, shape = 3, scale = 4)
source('~/OneDrive - Université Laval/Packages/Distributacalcul/R/Elim_gamma.R', echo=TRUE)
Elim_gamma(d = 2, shape = 3, scale = 4)
Elim_gamma(d = 2, shape = 3, rate = 0.25)
source('~/OneDrive - Université Laval/Packages/Distributacalcul/R/Etronq_gamma.R', echo=TRUE)
Etronq_gamma(d = 2, shape = 3, scale = 4)
Etronq_gamma(d = 2, shape = 3, rate = 0.25)
library(Distributacalcul)
library(Distributacalcul)
library(Distributacalcul)
library(Distributacalcul)
library(Distributacalcul)
library(Distributacalcul)
