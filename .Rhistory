p.NBCOMP.approx <- function(x) sum(X.ordered <= x)
p.NBCOMP.approx(10)
p.NBCOMP.approx <- function(x) sum(X.ordered <= x)/sum(X.ordered)
p.NBCOMP.approx(10)
p.NBCOMP.approx <- function(x) sum(X.ordered <= max(X.order))/sum(X.ordered)
p.NBCOMP.approx(10)
p.NBCOMP.approx(X.order)
p.NBCOMP.approx(max(X.order))
p.NBCOMP.approx(pmax(X.order))
sum(X.ordered)
sum(X.ordered <= x)
x=1
sum(X.ordered <= x)
x=max(X.order)
x
x=pmax(X.order)
x
x=max(X.order)
sum(X.ordered <= x)/sum(X.ordered)
p
p.NBCOMP.approx(max(X.order))
p.NBCOMP.approx <- function(x) sum(X.ordered <= x)/sum(X.ordered)
p.NBCOMP.approx(max(X.order))
p.NBCOMP.approx <- function(x) sum(X.ordered <= x)/length(X.ordered)
p.NBCOMP.approx(max(X.order))
p.NBCOMP.approx(min(X.order))
p.NBCOMP.approx(10)
p.NBCOMP.approx(20)
p.NBCOMP.approx(20)
p.NBCOMP.approx(0)
curve(p.NBCOMP.approx)
curve(p.NBCOMP.approx(x))
p.NBCOMP.approx <- function(x) sum(X.ordered <= x)/length(X.ordered)
curve(p.NBCOMP.approx(x))
curve(p.NBCOMP.approx(x))
plot(p.NBCOMP.approx(x))
curve(Vectorize(function(x)p.NBCOMP.approx(x)))
curve(Vectorize(function(k) p.NBCOMP.approx(x = k)))
curve(p.NBCOMP.approx(x))
ggplot(data = data.frame(x = c(0, 1)), mapping = aes(x)) +
geom_line(
stat = "function",
fun = p.NBCOMP.approx
)
ggplot(data = data.frame(x = c(0, 1)), mapping = aes(x)) +
geom_line(
stat = "function",
fun = Vectorize(function(x) p.NBCOMP.approx(x))
)
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = Vectorize(function(x) { # vectorize permet d'appliquer la fonction aux vecteurs de paramètres
p.NBCOMP.approx(x)
}),
mapping = aes(colour = "X_1 + X_2")
) +
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = Vectorize(function(x) { # vectorize permet d'appliquer la fonction aux vecteurs de paramètres
p.NBCOMP.approx(x)
}),
mapping = aes(colour = "X_1 + X_2")
)
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = Vectorize(function(x) { # vectorize permet d'appliquer la fonction aux vecteurs de paramètres
p.NBCOMP.approx(x)
}),
mapping = aes(colour = "X_1 + X_2")
)
sum(p.NBCOMP.approx(x))
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = Vectorize(function(x) { # vectorize permet d'appliquer la fonction aux vecteurs de paramètres
sum(p.NBCOMP.approx(x))
}),
mapping = aes(colour = "X_1 + X_2")
)
cumsum(p.NBCOMP.approx(x))
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = Vectorize(function(x) { # vectorize permet d'appliquer la fonction aux vecteurs de paramètres
cumsum(p.NBCOMP.approx(x))
}),
mapping = aes(colour = "X_1 + X_2")
)
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = Vectorize(function(k) { # vectorize permet d'appliquer la fonction aux vecteurs de paramètres
cumsum(p.NBCOMP.approx(k))
}),
mapping = aes(colour = "X_1 + X_2")
)
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = Vectorize(function(k) { # vectorize permet d'appliquer la fonction aux vecteurs de paramètres
p.NBCOMP.approx(k)
}),
mapping = aes(colour = "X_1 + X_2")
)
TVaR_gamma
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = p.NBCOMP.approx,
mapping = aes(colour = "X_1 + X_2")
)
which(X.ordered <= x)
p.NBCOMP.approx <- function(x) sum(which(X.ordered <= x))/length(X.ordered)
p.NBCOMP.approx(1)
which(X.ordered <= x)
X.ordered <= x
X.ordered <= x
X.ordered <= x
sum(X.ordered <= x)/length(X.ordered)
sum(X.ordered <= 0)/length(X.ordered)
p.NBCOMP.approx <- function(x) sum(X.ordered <= x)/length(X.ordered)
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = p.NBCOMP.approx,
mapping = aes(colour = "X_1 + X_2")
)
curve(p.NBCOMP.approx())
curve(p.NBCOMP.approx)
curve(p.NBCOMP.approx(x))
x
x
x
plot(p.NBCOMP.approx(x))
p.NBCOMP.approx <- Vectorize(function(x) sum(X.ordered <= x)/length(X.ordered))
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = p.NBCOMP.approx,
mapping = aes(colour = "X_1 + X_2")
)
curve(p.NBCOMP.approx(x))
p.NBCOMP.approx <- Vectorize(function(x) {sum(X.ordered <= x)/length(X.ordered)})
curve(p.NBCOMP.approx(x))
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = p.NBCOMP.approx,
mapping = aes(colour = "X_1 + X_2")
)
library(Distributacalcul)
devtools::build_manual()
#' @export
#'
#' @examples
#'
#' # With scale parameter
#' V_burr(rate = 2, shape1 = 2, shape2 = 5)
#'
#' # With rate parameter
#' V_burr(scale = 0.5, shape1 = 2, shape2 = 5)
#'
V_burr <- function(shape1, shape2, rate = 1 / scale, scale = 1 / rate) {
stopifnot(shape1 > 0, shape2 > 0, rate > 0)
(rate^(2/shape2) / gamma(shape1)) *
(
gamma(1 + 2/shape2) * gamma(shape1 - 2/shape2) -
((gamma(1 + 1/shape2) * gamma(shape1 - 1/shape2))^2) / gamma(shape1)
)
}
V_burr(shape1 = 2, shape2 = 3, rate = 1)
source('~/OneDrive - Université Laval/Packages/Distributacalcul/R/kthmoment_burr.R', echo=TRUE)
source('~/OneDrive - Université Laval/Packages/Distributacalcul/R/E_burr.R', echo=TRUE)
kthmoment_burr(k = 2, shape1 = 2, shape2 = 3, rate = 1) - E_burr(shape1 = 2, shape2 = 3, rate = 1)^2
V_burr(shape1 = 2, shape2 = 3, rate = 1)
source('~/OneDrive - Université Laval/Packages/Distributacalcul/R/E_burr.R', echo=TRUE)
source('~/OneDrive - Université Laval/Packages/Distributacalcul/R/V_burr.R', echo=TRUE)
stopifnot(shape1 > 0, shape2 > 0, rate > 0, k > -shape2, k < shape1 * shape2)
#' @export
#'
#' @examples
#'
#' # With scale parameter
#' kthmoment_burr(k = 1, rate = 2, shape1 = 2, shape2 = 5)
#'
#' # With rate parameter
#' kthmoment_burr(k = 1, scale = 0.5, shape1 = 2, shape2 = 5)
#'
kthmoment_burr <- function(k, rate = 1 / scale, scale = 1 / rate, shape1, shape2) {
stopifnot(shape1 > 0, shape2 > 0, rate > 0, k > -shape2, k < shape1 * shape2)
(1/gamma(shape1)) *
rate^(k/shape2) *
gamma(1 + k/shape2) *
gamma(shape1 - k/shape2)
}
library(Distributacalcul)
source('~/OneDrive - Université Laval/Packages/Distributacalcul/R/E_burr.R', echo=TRUE)
source('~/OneDrive - Université Laval/Packages/Distributacalcul/R/V_burr.R', echo=TRUE)
source('~/OneDrive - Université Laval/Packages/Distributacalcul/R/Elim_burr.R', echo=TRUE)
source('~/OneDrive - Université Laval/Packages/Distributacalcul/R/Etronq_burr.R', echo=TRUE)
kthmoment_burr(k = 2, rate = 1, shape1 = 2, shape2 = 4)
kthmoment_burr(k = -2, rate = 1, shape1 = 2, shape2 = 4)
kthmoment_burr(k = -5, rate = 1, shape1 = 2, shape2 = 4)
kthmoment_burr(k = 9, rate = 1, shape1 = 2, shape2 = 4)
kthmoment_burr(k = 2, rate = 1, shape1 = 2, shape2 = 4)
kthmoment_burr(k = 1, scale = 0.5, shape1 = 2, shape2 = 5)
kthmoment_burr(k = 1, rate = 2, shape1 = 2, shape2 = 5)
library(Distributacalcul)
Etronq_burr(d = 2, scale = 0.5, shape1 = 2, shape2 = 5, less.than.d = FALSE)
source('~/OneDrive - Université Laval/Packages/Distributacalcul/R/Etronq_burr.R', echo=TRUE)
Etronq_burr(d = 2, scale = 0.5, shape1 = 2, shape2 = 5, less.than.d = FALSE)
Etronq_burr(d = 2, scale = 0.5, shape1 = 2, shape2 = 5)
library(Distributacalcul)
library(Distributacalcul)
library(Distributacalcul)
2 / 4 * 3
(2 / 4) * 3
1/2 * 4
(1/2) * 4
library(Distributacalcul)
library(Distributacalcul)
library(Distributacalcul)
devtools::build_manual()
devtools::build_manual()
library(Distributacalcul)
library(Distributacalcul)
source('~/.active-rstudio-document', echo=TRUE)
f_s <- vector(length = 10)
distr.param <- list(
prob = 0.20,
size = 5
)
dbinom(q = 0, size = distr.param$size, prob = distr.param$prob)
f_s[0] <- dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)
dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)
f_s[0] <- dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)^m
f_s
dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)^m
i=1
dbinom(x = i, size = distr.param$size, prob = distr.param$prob)
dbinom(x = i, size = distr.param$size, prob = distr.param$prob)
i=1
f_s[i] <- dbinom(x = i, size = distr.param$size, prob = distr.param$prob) *
f_s[i - 1] *
((m + 1) * (i/i) - 1) /
dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)
i=1
dbinom(x = i, size = distr.param$size, prob = distr.param$prob) *
f_s[i - 1] *
((m + 1) * (i/i) - 1) /
dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)
dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)
((m + 1) * (i/i) - 1)
f_s[i - 1]
f_s[0] <- dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)^m
f_s
f_s[i - 1]
f_s
f_s[0]
f_s[i] <- dbinom(x = i, size = distr.param$size, prob = distr.param$prob) *
f_s[(i - 1) + 1] *
((m + 1) * (i/i) - 1) /
dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)
f_s
dbinom(x = i, size = distr.param$size, prob = distr.param$prob)
dbinom(x = i, size = distr.param$size, prob = distr.param$prob) *
f_s[(i - 1) + 1] *
((m + 1) * (i/i) - 1) /
dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)
k=2
f_s[k] <- (
sum(sapply(1:k, function(j) {
dbinom(x = j, size = distr.param$size, prob = distr.param$prob) *
f_s[(k - j) + 1] *
((m + 1) * (j/k) - 1)
}))
) / dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)
f_s
seq_along(m)
m <- 10
seq_along(m)
seq_len(m)
f_s <- vector(length = 10)
f_s[0] <- dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)^m
for (k in seq_len(m)) {
f_s[k] <- (
sum(sapply(1:k, function(j) {
dbinom(x = j, size = distr.param$size, prob = distr.param$prob) *
f_s[(k - j) + 1] *
((m + 1) * (j/k) - 1)
}))
) / dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)
}
f_s
x <- 4
for (k in seq_len(x)) {
f_s[k] <- (
sum(sapply(1:k, function(j) {
dbinom(x = j, size = distr.param$size, prob = distr.param$prob) *
f_s[(k - j) + 1] *
((m + 1) * (j/k) - 1)
}))
) / dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)
}
return(f_s[x+ 1])
x <- 4
f_s <- vector(length = x)
f_s
x <- 4
f_s <- vector(length = x + 1)
f_s[0] <- dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)^m
f_s[1] <- dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)^m
f_s
for (k in seq_len(x)) {
f_s[k] <- (
sum(sapply(1:k, function(j) {
dbinom(x = j, size = distr.param$size, prob = distr.param$prob) *
f_s[(k - j) + 1] *
((m + 1) * (j/k) - 1)
}))
) / dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)
}
return(f_s[x+ 1])
f_s[x+ 1]
f_s
dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)^m
0.000014
x <- 4
f_s <- vector(length = x + 1)
f_s[1] <- dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)^m
for (k in seq_len(x)) {
f_s[k + 1] <- (
sum(sapply(1:k, function(j) {
dbinom(x = j, size = distr.param$size, prob = distr.param$prob) *
f_s[(k - j) + 1] *
((m + 1) * (j/k) - 1)
}))
) / dbinom(x = 0, size = distr.param$size, prob = distr.param$prob)
}
return(f_s[x+ 1])
f_s[x+ 1]
TVaR_exp(kap = 0.9, rate = 1)
library(Distributacalcul)
TVaR_exp(kap = 0.9, rate = 1)
TVaR_gamma(kap = 0.9, rate = 1, shape = 2)
TVaR_gamma(kap = 0.99, rate = 1, shape = 2)
TVaR_gamma(kap = 0.34, rate = 1, shape = 2)
library(Distributacalcul)
library(Distributacalcul)
library(Distributacalcul)
E_lnorm
2 %% 1
2 %% 1 == 0
3 %% 1 == 0
3 %% 1
3 %% 2
4 %% 2
5 %% 2
5 %% 2 == 0
is.integer(5)
5 %% 2 == 0
5 %% 2
4 %% 2
4.4 %% 2
5.4 %% 2
5.4 %% 1
5 %% 1
4 %% 1
3 %% 1
4.2 %% 1
Elim_erlang(d = 2, shape = 2, rate = 0.2)
#' @export
#'
#' @examples
#'
#' # With scale parameter
#' perlang(q = 2, shape = 2, scale = 5)
#'
#' # With rate parameter
#' perlang(q = 2, shape = 2, rate = 0.2)
#'
perlang <- function(q, shape, scale = 1 / rate, rate = 1 / scale, lower.tail = TRUE)
{
stopifnot(q >= 0, shape %% 1 == 0, rate > 0)
Fx <- exp(-rate * q) *
sum(sapply(0:(shape - 1), function(j) ((rate * q)^j) / factorial(j)))
if (lower.tail == T) {
(1 - Fx)
} else {
Fx
}
}
perlang(q = 2, shape = 2, rate = 0.2)
#'  parameter \eqn{n} and rate parameter \eqn{\beta}{beta}.
#'
#' @templateVar kap TRUE
#' @templateVar vark TRUE
#' @templateVar q FALSE
#' @template erlang-template
#'
#' @details This formula needs the formula for the VaR_erlang (already installed with the tvarPackage).
#'
#' @export
.TVaR_erlang <- function(kap, shape, scale = 1 / rate, rate = 1 / scale, vark)
{
stopifnot(kap >= 0, kap <= 1, shape %% 1 == 0, rate > 0)
(shape / ((1 - kap) * rate)) *
(exp(-rate * vark) *
sum(sapply(0:shape, function(j) ((rate * vark)^j)/factorial(j)))
)
}
#' @importFrom stats pgamma
#'
#' @examples
#'
#' # With scale parameter
#' Mexcess_erlang(d = 2, shape = 2, scale = 5)
#'
#' # With rate parameter
#' Mexcess_erlang(d = 2, shape = 2, rate = 0.2)
#'
Mexcess_erlang <- function(d, shape, scale = 1 / rate, rate = 1 / scale)
{
stopifnot(d >= 0, shape %% 1 == 0, rate > 0)
(shape / rate) *
pgamma(q = d, shape = shape + 1, rate = rate, lower.tail = F) /
pgamma(q = d, shape = shape, rate = rate, lower.tail = F) -
d
}
Mexcess_erlang(d = 2, shape = 2, rate = 0.2)
Mexcess_erlang(d = 2, shape = 2, scale = 5)
Mexcess_erlang(d = 2, shape = 3, scale = 5)
Mexcess_erlang(d = 2, shape = 3.5, scale = 5)
#' @export
#'
#' @examples
#'
#' # With scale parameter
#' Mexcess_exp(d = 2, scale = 4)
#'
#' # With rate parameter
#' Mexcess_exp(d = 5, rate = 0.25)
#'
Mexcess_exp <- function(d, rate = 1 / scale, scale = 1 / rate) {
stopifnot(d >= 0, rate > 0)
E_exp(rate)
}
Mexcess_exp(d = 5, rate = 0.25)
#' @importFrom stats pgamma
#'
#' @examples
#'
#' # With scale parameter
#' Mexcess_erlang(d = 2, shape = 2, scale = 5)
#'
#' # With rate parameter
#' Mexcess_erlang(d = 2, shape = 2, rate = 0.2)
#'
Mexcess_erlang <- function(d, shape, scale = 1 / rate, rate = 1 / scale)
{
stopifnot(d >= 0, shape %% 1 == 0, rate > 0)
(shape / rate) *
pgamma(q = d, shape = shape + 1, rate = rate, lower.tail = F) /
pgamma(q = d, shape = shape, rate = rate, lower.tail = F) -
d
}
Mexcess_erlang(d = 2, shape = 2, rate = 0.2)
#' @export
#'
#' @examples
#'
#' # With scale parameter
#' Mexcess_burr(d = 2, rate = 2, shape1 = 2, shape2 = 5)
#'
#' # With rate parameter
#' Mexcess_burr(d = 2, scale = 0.5, shape1 = 2, shape2 = 5)
#'
Mexcess_burr <- function(d, shape1, shape2, rate = 1 / scale, scale = 1 / rate) {
stopifnot(shape1 > 0, shape2 > 0, rate > 0, d >= 0)
(
((rate + d^shape2)^shape1) *
gamma(1 + 1/shape2) *
gamma(shape1 - 1/shape2)
) / (
(rate ^ (shape1 - 1/shape2)) *
gamma(shape1)
) *
pbeta(
q = (d^shape2) / (rate + (d^shape2)),
shape1 = 1 + 1/shape2,
shape2 = shape1 - 1/shape2,
lower.tail = F) -
d
}
Mexcess_burr(d = 2, scale = 0.5, shape1 = 2, shape2 = 5)
Mexcess_burr(d = 2, rate = 2, shape1 = 2, shape2 = 5)
library(Distributacalcul)
devtools::load_all("~/OneDrive - Université Laval/Packages/Distributacalcul")
