E_BNCOMP(size = 4, prob = 0.4, shape = 0, rate = 2, distr_severity = "lognormal")
E_BNCOMP(size = 4, prob = 0.4, shape = 0, rate = 2, distr_severity = "lognormal")
E_gamma(shape = 3, scale = 4)
E_BNCOMP(size = distr.param$size, prob = distr.param$prob, shape = distr.param$meanlog, rate = distr.param$sdlog, distr_severity = "Lognormale")
E_BNCOMP(size = distr.param$size, prob = distr.param$prob, shape = distr.param$meanlog, rate = distr.param$sdlog, distr_severity = "Lognormale")
#' @details Cette formule utilise aussi un choix de 2 distributions pour la sévérité; soit la Gamma ou la Lognormale.
#'
#' @param size r pour la binomiale négative
#' @param prob probabilité q pour la binomiale
#' @param shape alpha pour la Gamma et mu pour la lognormale
#' @param rate beta pour la Gamma et sigma^2 pour la lognormale
#' @param distr_severity choice of severity distribution Gamma (default) or Lognormal
#'
#' @export
#'
V_BNCOMP <- function(size, prob, shape, rate, distr_severity = "Gamma")
{
stopifnot(prob >= 0, prob <= 1, rate > 0)
if (grepl(pattern = "^Gamma$", x = distr_severity, ignore.case = TRUE)) {
V.BNCOMP <- E_gamma(shape, rate)^2 * V_negbinom(size, prob, nb_tries = FALSE) + V_gamma(shape, rate) * E_negbinom(size, prob, nb_tries = FALSE)
} else if (grepl(pattern = "^Lognormal[e]*$", x = distr_severity, ignore.case = TRUE)) {
V.BNCOMP <- E_negbinom(size, prob, nb_tries = FALSE) * (E_lnorm(shape, sqrt(rate)) / prob + V_lnorm(shape, sqrt(rate)))
} else {
stop("Please enter a valid distribution choice. Either 'Lognormal' or 'Gamma'")
}
return(V.BNCOMP)
}
#' @param size r pour la binomiale négative
#' @param prob probabilité q pour la binomiale
#' @param shape alpha pour la Gamma et mu pour la lognormale
#' @param rate beta pour la Gamma et sigma^2 pour la lognormale
#' @param distr_severity choice of severity distribution Gamma (default) or Lognormal
#' @param vark Value at Risk (VaR) calculé au même niveau de confiance kap
#' @param ko borne pour la somme dans le calcul de la TVaR.
#'
#' @export
#'
VaR_BNCOMP <- function(kap, vark, size, prob, shape, rate, distr_severity = "Gamma", ko)
{
stopifnot(prob >= 0, prob <= 1, rate > 0)
stopifnot(grepl(pattern = "(^Gamma$)|(^Lognormal[e]*$)", x = distr_severity, ignore.case = TRUE))
if (kap <= p_BNCOMP(0, size, prob, shape, rate, ko, distr_severity)) {
0
} else {
optimize(function(i) abs(p_BNCOMP(i, size, prob, ko, shape, rate) - kap), c(0, ko))$minimum
}
}
VaR_BNCOMP(kap = 0.4, vark = 10, size =  5, prob = 0.4, shape = 5, rate = 45, distr_severity = "Lognormal", ko = 1E4)
#' @param size r pour la binomiale négative
#' @param prob probabilité q pour la binomiale
#' @param shape alpha pour la Gamma et mu pour la lognormale
#' @param rate beta pour la Gamma et sigma^2 pour la lognormale
#' @param distr_severity choice of severity distribution Gamma (default) or Lognormal
#' @param vark Value at Risk (VaR) calculé au même niveau de confiance kap
#' @param ko borne pour la somme dans le calcul de la TVaR.
#'
#' @export
#'
VaR_BNCOMP <- function(kap, vark, size, prob, shape, rate, distr_severity = "Gamma", ko)
{
stopifnot(prob >= 0, prob <= 1, rate > 0)
stopifnot(grepl(pattern = "(^Gamma$)|(^Lognormal[e]*$)", x = distr_severity, ignore.case = TRUE))
if (kap <= p_BNCOMP(x = 0, size, prob, shape, rate, ko = ko, distr_severity = distr_severity)) {
0
} else {
optimize(function(i) abs(p_BNCOMP(i, size, prob, ko, shape, rate) - kap), c(0, ko))$minimum
}
}
VaR_BNCOMP(kap = 0.4, vark = 10, size =  5, prob = 0.4, shape = 5, rate = 45, distr_severity = "Lognormal", ko = 1E4)
kap = 0.4; vark = 10; size =  5; prob = 0.4, shape = 5; rate = 45; distr_severity = "Lognormal"; ko = 1E4
kap = 0.4
vark = 10
size =  5
prob = 0.4; shape = 5; rate = 45; distr_severity = "Lognormal"; ko = 1E4
shpae
shape
p_BNCOMP(x = 0, size, prob, shape, rate, ko = ko, distr_severity = distr_severity)
#' Répartition d'une loi binomiale négative composée
#' @param x x
#' @param size r pour la binomiale négative (nombre d'échecs).
#' @param prob probabilité q pour la binomiale
#' @param shape alpha pour la Gamma
#' @param rate beta pour la Gamma
#' @param ko borne pour la sommation de la fonction de répartition
#' @param distr_severity choix de distribution de sévérité.
#' @export
p_BNCOMP <- function(x, size, prob, shape, rate, ko, distr_severity = "Gamma") {
stopifnot(prob >= 0, prob <= 1, rate > 0)
stopifnot(grepl(pattern = "(^Gamma$)", x = distr_severity, ignore.case = TRUE))
if (grepl(pattern = "^Gamma$", x = distr_severity, ignore.case = TRUE)) {
dnbinom(x = 0, size = size, prob = prob) +
sum(sapply(1:ko, function(i) dnbinom(x = i, size = size, prob = prob) * pgamma(q = x, shape = shape * i, rate = rate)))
}
}
p_BNCOMP(x = 0, size, prob, shape, rate, ko = ko, distr_severity = distr_severity)
p_BNCOMP(x = 0, size, prob, shape, rate, ko = ko, distr_severity = distr_severity)
p_BNCOMP(x = 0, size, prob, shape, rate, ko = ko, distr_severity = distr_severity)
p_BNCOMP(x = 0, size, prob, shape, rate, ko = ko, distr_severity = distr_severity)
p_BNCOMP(x = 0, size, prob, shape, rate, ko = ko, distr_severity = distr_severity)
p_BNCOMP(x = 0, size, prob, shape, rate, ko = ko, distr_severity = distr_severity)
p_BNCOMP(x = 0, size, prob, shape, rate, ko = ko, distr_severity = distr_severity)
p_BNCOMP(x = 0, size, prob, shape, rate, ko = ko, distr_severity = distr_severity)
distr_severity = "lognormale"
p_BNCOMP(x = 0, size, prob, shape, rate, ko = ko, distr_severity = distr_severity)
distr_severity = "gamma"
p_BNCOMP(x = 0, size, prob, shape, rate, ko = ko, distr_severity = distr_severity)
kap
#' @param size r pour la binomiale négative
#' @param prob probabilité q pour la binomiale
#' @param shape alpha pour la Gamma et mu pour la lognormale
#' @param rate beta pour la Gamma et sigma^2 pour la lognormale
#' @param distr_severity choice of severity distribution Gamma (default) or Lognormal
#' @param vark Value at Risk (VaR) calculé au même niveau de confiance kap
#' @param ko borne pour la somme dans le calcul de la TVaR.
#'
#' @export
#'
VaR_BNCOMP <- function(kap, vark, size, prob, shape, rate, distr_severity = "Gamma", ko) {
stopifnot(prob >= 0, prob <= 1, rate > 0)
stopifnot(grepl(pattern = "(^Gamma$)", x = distr_severity, ignore.case = TRUE))
if (kap <= p_BNCOMP(x = 0, size, prob, shape, rate, ko = ko, distr_severity = distr_severity)) {
0
} else {
optimize(function(i) abs(p_BNCOMP(i, size, prob, ko, shape, rate) - kap), c(0, ko))$minimum
}
}
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 1E3)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 1E2)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 1E5)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 1E6)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 1E4)
1E4
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 1E3)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 2E3)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 2E2)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 10)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 5)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 1e2)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 1e4)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 2e4)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 2e3)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 2e2)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 5e2)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 5e4)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 5e3)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 5e2)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 5e4)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 5e4)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 5e4)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 5e4)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 5e3)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 5e2)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 3e3)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 2e3)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 1e3)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 1500)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 1200)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 1300)
VaR_BNCOMP(kap = 0.99, size = 4, prob = 0.4, shape = 5, rate = 10, distr_severity = "Gamma", ko = 1500)
E_BNCOMP(size = distr.param$size, prob = distr.param$prob, shape = distr.param$meanlog, rate = distr.param$sdlog, distr_severity = "Lognormale")
E_BNCOMP(size = distr.param$size, prob = distr.param$prob, shape = distr.param$meanlog, rate = distr.param$sdlog, distr_severity = "Lognormale")
E_BNCOMP(size = distr.param$size, prob = distr.param$prob, shape = distr.param$meanlog, rate = distr.param$sdlog, distr_severity = "Lognormale")
V_BNCOMP(size = distr.param$size, prob = distr.param$prob, shape = distr.param$meanlog, rate = distr.param$sdlog, distr_severity = "Lognormale")
sqrt(V_BNCOMP(size = distr.param$size, prob = distr.param$prob, shape = distr.param$meanlog, rate = distr.param$sdlog, distr_severity = "Lognormale"))
V_BNCOMP(size = 5, prob = 0.20, shape = 2, rate = 1/5000, distr_severity = "gamma")
V_BNCOMP(size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "gamma")
V_BNCOMP(size = 5, prob = 0.20, shape = 2, rate = 5000, distr_severity = "gamma")
V_BNCOMP(size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
size = 5; prob = 1/5; shape = 2; rate = 1/5000; distr_severity = "Gamma"
E_gamma(shape, rate)^2 * V_negbinom(size, prob, nb_tries = FALSE) + V_gamma(shape, rate) * E_negbinom(size, prob, nb_tries = FALSE)
E_BNCOMP(size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
2E5
200000
p_BNCOMP(x = 5E5, ko = 1E3, size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
V_BNCOMP(size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
E_BNCOMP(size = 4, prob = 0.4, shape = 0, rate = 2, distr_severity = "lognormal")
TVaR_BNCOMP(kap = 0.99, ko = 1E4, size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
VaR_BNCOMP(kap = 0.99, ko = 1E4, size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
#' @param size r pour la binomiale négative
#' @param prob probabilité q pour la binomiale
#' @param shape alpha pour la Gamma et mu pour la lognormale
#' @param rate beta pour la Gamma et sigma^2 pour la lognormale
#' @param distr_severity choice of severity distribution Gamma (default)ss
#' @param vark Value at Risk (VaR) calculé au même niveau de confiance kap
#' @param ko borne pour la somme dans le calcul de la TVaR.
#'
#' @export
#'
TVaR_BNCOMP <- function(kap, vark, size, prob, shape, rate, distr_severity = "Gamma", ko)
{
stopifnot(prob >= 0, prob <= 1, rate > 0)
stopifnot(grepl(pattern = "(^Gamma$)|(^Lognormal[e]*$)", x = distr_severity, ignore.case = TRUE))
if (vark == 0) {
TVaR.BNCOMP <- E_BNComp(size, prob, shape, rate, distr_severity) / (1 - kap)
} else if (grepl(pattern = "^Gamma$", x = distr_severity, ignore.case = TRUE)) {
TVaR.BNCOMP <- sum(sapply(1:ko, function(i)
dnbinom(x = i, size = size, prob = prob) *
E_gamma(shape, rate) *
pgamma(q = vark, shape = shape * i + 1, rate = rate, lower.tail = F))
) / (1 - kap)
} else {
stop("Please enter a valid distribution choice. 'Gamma'")
}
return(TVaR.BNCOMP)
}
VaR_BNCOMP(kap = 0.99, ko = 1E4, size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
vark <- VaR_BNCOMP(kap = 0.99, ko = 1E4, size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
TVaR_BNCOMP(kap = 0.99, ko = 1E4, vark = vark, size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
TVaR_BNCOMP(kap = 0.99, ko = 1E5, vark = vark, size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
vark <- VaR_BNCOMP(kap = 0.99, ko = 1E5, size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
TVaR_BNCOMP(kap = 0.99, ko = 1E5, vark = vark, size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
TVaR_BNCOMP(kap = 0.99, ko = 1E6, vark = vark, size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
vark <- VaR_BNCOMP(kap = 0.99, ko = 1E6, size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
TVaR_BNCOMP(kap = 0.99, ko = 1E6, vark = vark, size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
vark
p_BNCOMP(x = 5E5, ko = 1E3, size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
p_BNCOMP(x = 5E6, ko = 1E3, size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
p_BNCOMP(x = 6E5, ko = 1E3, size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
vark <- VaR_BNCOMP(kap = 0.99, ko = 7E5, size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
vark
TVaR_BNCOMP(kap = 0.99, ko = 7E5, vark = vark, size = 5, prob = 1/5, shape = 2, rate = 1/5000, distr_severity = "Gamma")
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
library(Distributacalcul)
rnbinom(n = 1, size = distr.param$size, prob = distr.param$prob)
m <- 1E6z
m <- 1E6
M <- vector(length = m)
M
j <- 1
M[j] <- rnbinom(n = 1, size = distr.param$size, prob = distr.param$prob)
M[j]
M[j] <- rnbinom(n = 1, size = distr.param$size, prob = distr.param$prob)
M[j]
M[j] <- rnbinom(n = 1, size = distr.param$size, prob = distr.param$prob)
M[j]
M[j] <- rnbinom(n = 1, size = distr.param$size, prob = distr.param$prob)
M[j]
X <- vector(length = m)
1:M[j]
M[j]
M[j] <- rnbinom(n = 1, size = distr.param$size, prob = distr.param$prob)
1:M[j]
M[j] <- rnbinom(n = 1, size = distr.param$size, prob = distr.param$prob)
M[j]
M[j] <- rnbinom(n = 1, size = distr.param$size, prob = distr.param$prob)
M[j]
M[j] <- rnbinom(n = 1, size = distr.param$size, prob = distr.param$prob)
M[j]
1:M[j]
B <- vector(length = M[j])
B
B[i] <- rlnorm(n = 1, meanlog = distr.param$meanlog, sdlog = distr.param$sdlog)
i=1
B[i] <- rlnorm(n = 1, meanlog = distr.param$meanlog, sdlog = distr.param$sdlog)
B[i]
for (i in 1:M[j]) {
B[i] <- rlnorm(n = 1, meanlog = distr.param$meanlog, sdlog = distr.param$sdlog)
}
B
sum(B)
1:m
m <- 1E6
M <- vector(length = m)
X <- vector(length = m)
set.seed(2019)
for (i in 1:m) {
M[j] <- rnbinom(n = 1, size = distr.param$size, prob = distr.param$prob) # simul une réalisation d'une distribution binomiale négative
if (M[j] == 0) { # si elle est nulle alors X est null
X[j] <- 0
} else { # sinon, on simule M[j] réalisations d'une distribution lognormale
B <- vector(length = M[j])
for (i in 1:M[j]) {
B[i] <- rlnorm(n = 1, meanlog = distr.param$meanlog, sdlog = distr.param$sdlog)
}
X[j] <- sum(B) # puis on pose X = somme des réalisations
}
}
X
hist(X)
m <- 1E6
M <- vector(length = m)
X <- vector(length = m)
set.seed(2019)
for (j in 1:m) {
M[j] <- rnbinom(n = 1, size = distr.param$size, prob = distr.param$prob) # simul une réalisation d'une distribution binomiale négative
if (M[j] == 0) { # si elle est nulle alors X est null
X[j] <- 0
} else { # sinon, on simule M[j] réalisations d'une distribution lognormale
B <- vector(length = M[j])
for (i in 1:M[j]) {
B[i] <- rlnorm(n = 1, meanlog = distr.param$meanlog, sdlog = distr.param$sdlog)
}
X[j] <- sum(B) # puis on pose X = somme des réalisations
}
}
library(tidyverse)
ggplot(data = data.frame(x = X)) +
geom_histogram(mapping = aes(x = x))
ggplot(data = data.frame(x = X)) +
geom_histogram(mapping = aes(x = x),
bins = 50)
# hist(X)
#   ou, plus beau
ggplot(data = data.frame(x = X)) +
geom_histogram(mapping = aes(x = x),
bins = 50)
hist(X)
# hist(X)
#   ou, plus beau
ggplot(data = data.frame(x = X)) +
geom_histogram(mapping = aes(x = x),
bins = 50)
# hist(X)
#   ou, plus beau
ggplot(data = data.frame(x = X)) +
geom_histogram(mapping = aes(x = x),
bins = 50)
# Ordre -------------------------------------------------------------------
sort(X)
# Ordre -------------------------------------------------------------------
tail(sort(X))
# Ordre -------------------------------------------------------------------
X.order <- sort(X)
# Ordre -------------------------------------------------------------------
X.ordered <- sort(X)
E.NBCOMP.approx <- mean(X)
E.NBCOMP.approx
# Moments -----------------------------------------------------------------
E_BNCOMP(size = distr.param$size, prob = distr.param$prob, shape = distr.param$meanlog, rate = distr.param$sdlog, distr_severity = "Lognormale")
V.NBCOMP.approx <- sd(X)
V.NBCOMP.approx
sqrt(V_BNCOMP(size = distr.param$size, prob = distr.param$prob, shape = distr.param$meanlog, rate = distr.param$sdlog, distr_severity = "Lognormale"))
p.NBCOMP.approx <- function(x) sum(X.ordered <= x)
p.NBCOMP.approx(10)
p.NBCOMP.approx <- function(x) sum(X.ordered <= x)/sum(X.ordered)
p.NBCOMP.approx(10)
p.NBCOMP.approx <- function(x) sum(X.ordered <= max(X.order))/sum(X.ordered)
p.NBCOMP.approx(10)
p.NBCOMP.approx(X.order)
p.NBCOMP.approx(max(X.order))
p.NBCOMP.approx(pmax(X.order))
sum(X.ordered)
sum(X.ordered <= x)
x=1
sum(X.ordered <= x)
x=max(X.order)
x
x=pmax(X.order)
x
x=max(X.order)
sum(X.ordered <= x)/sum(X.ordered)
p
p.NBCOMP.approx(max(X.order))
p.NBCOMP.approx <- function(x) sum(X.ordered <= x)/sum(X.ordered)
p.NBCOMP.approx(max(X.order))
p.NBCOMP.approx <- function(x) sum(X.ordered <= x)/length(X.ordered)
p.NBCOMP.approx(max(X.order))
p.NBCOMP.approx(min(X.order))
p.NBCOMP.approx(10)
p.NBCOMP.approx(20)
p.NBCOMP.approx(20)
p.NBCOMP.approx(0)
curve(p.NBCOMP.approx)
curve(p.NBCOMP.approx(x))
p.NBCOMP.approx <- function(x) sum(X.ordered <= x)/length(X.ordered)
curve(p.NBCOMP.approx(x))
curve(p.NBCOMP.approx(x))
plot(p.NBCOMP.approx(x))
curve(Vectorize(function(x)p.NBCOMP.approx(x)))
curve(Vectorize(function(k) p.NBCOMP.approx(x = k)))
curve(p.NBCOMP.approx(x))
ggplot(data = data.frame(x = c(0, 1)), mapping = aes(x)) +
geom_line(
stat = "function",
fun = p.NBCOMP.approx
)
ggplot(data = data.frame(x = c(0, 1)), mapping = aes(x)) +
geom_line(
stat = "function",
fun = Vectorize(function(x) p.NBCOMP.approx(x))
)
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = Vectorize(function(x) { # vectorize permet d'appliquer la fonction aux vecteurs de paramètres
p.NBCOMP.approx(x)
}),
mapping = aes(colour = "X_1 + X_2")
) +
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = Vectorize(function(x) { # vectorize permet d'appliquer la fonction aux vecteurs de paramètres
p.NBCOMP.approx(x)
}),
mapping = aes(colour = "X_1 + X_2")
)
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = Vectorize(function(x) { # vectorize permet d'appliquer la fonction aux vecteurs de paramètres
p.NBCOMP.approx(x)
}),
mapping = aes(colour = "X_1 + X_2")
)
sum(p.NBCOMP.approx(x))
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = Vectorize(function(x) { # vectorize permet d'appliquer la fonction aux vecteurs de paramètres
sum(p.NBCOMP.approx(x))
}),
mapping = aes(colour = "X_1 + X_2")
)
cumsum(p.NBCOMP.approx(x))
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = Vectorize(function(x) { # vectorize permet d'appliquer la fonction aux vecteurs de paramètres
cumsum(p.NBCOMP.approx(x))
}),
mapping = aes(colour = "X_1 + X_2")
)
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = Vectorize(function(k) { # vectorize permet d'appliquer la fonction aux vecteurs de paramètres
cumsum(p.NBCOMP.approx(k))
}),
mapping = aes(colour = "X_1 + X_2")
)
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = Vectorize(function(k) { # vectorize permet d'appliquer la fonction aux vecteurs de paramètres
p.NBCOMP.approx(k)
}),
mapping = aes(colour = "X_1 + X_2")
)
TVaR_gamma
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = p.NBCOMP.approx,
mapping = aes(colour = "X_1 + X_2")
)
which(X.ordered <= x)
p.NBCOMP.approx <- function(x) sum(which(X.ordered <= x))/length(X.ordered)
p.NBCOMP.approx(1)
which(X.ordered <= x)
X.ordered <= x
X.ordered <= x
X.ordered <= x
sum(X.ordered <= x)/length(X.ordered)
sum(X.ordered <= 0)/length(X.ordered)
p.NBCOMP.approx <- function(x) sum(X.ordered <= x)/length(X.ordered)
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = p.NBCOMP.approx,
mapping = aes(colour = "X_1 + X_2")
)
curve(p.NBCOMP.approx())
curve(p.NBCOMP.approx)
curve(p.NBCOMP.approx(x))
x
x
x
plot(p.NBCOMP.approx(x))
p.NBCOMP.approx <- Vectorize(function(x) sum(X.ordered <= x)/length(X.ordered))
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = p.NBCOMP.approx,
mapping = aes(colour = "X_1 + X_2")
)
curve(p.NBCOMP.approx(x))
p.NBCOMP.approx <- Vectorize(function(x) {sum(X.ordered <= x)/length(X.ordered)})
curve(p.NBCOMP.approx(x))
ggplot(data = data.frame(x.range = c(0, 1)),  # je crée un data.frame bidon qui contient deux éléments que je vais utilsier comme borne pour tracer le graphique
mapping = aes(x = x.range)) +
geom_line(
stat = "function",
fun = p.NBCOMP.approx,
mapping = aes(colour = "X_1 + X_2")
)
library(Distributacalcul)
devtools::build_manual()
